{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{\"+75Z\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return PageSizes}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return PaginatorState});const PageSizes=[3,5,10,15,50,100];class PaginatorState{constructor(){this.page=1,this.pageSize=PageSizes[2],this.total=0,this.pageSizes=[]}recalculatePaginator(total){return this.total=total,this}}},\"4NA8\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return NgbDateCustomParserFormatter});var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"1kSV\"),_angular_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"fXoL\");let NgbDateCustomParserFormatter=(()=>{class NgbDateCustomParserFormatter extends _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_0__.c{parse(value){if(value){const dateParts=value.trim().split(\"/\");if(1===dateParts.length&&isNumber(dateParts[0]))return{day:toInteger(dateParts[0]),month:null,year:null};if(2===dateParts.length&&isNumber(dateParts[0])&&isNumber(dateParts[1]))return{day:toInteger(dateParts[0]),month:toInteger(dateParts[1]),year:null};if(3===dateParts.length&&isNumber(dateParts[0])&&isNumber(dateParts[1])&&isNumber(dateParts[2]))return{day:toInteger(dateParts[0]),month:toInteger(dateParts[1]),year:toInteger(dateParts[2])}}return null}format(date){return date?`${isNumber(date.day)?padNumber(date.day):\"\"}/${isNumber(date.month)?padNumber(date.month):\"\"}/${date.year}`:\"\"}}return NgbDateCustomParserFormatter.ɵfac=function(t){return ɵNgbDateCustomParserFormatter_BaseFactory(t||NgbDateCustomParserFormatter)},NgbDateCustomParserFormatter.ɵprov=_angular_core__WEBPACK_IMPORTED_MODULE_1__.Kb({token:NgbDateCustomParserFormatter,factory:NgbDateCustomParserFormatter.ɵfac}),NgbDateCustomParserFormatter})();const ɵNgbDateCustomParserFormatter_BaseFactory=_angular_core__WEBPACK_IMPORTED_MODULE_1__.Wb(NgbDateCustomParserFormatter);function toInteger(value){return parseInt(\"\"+value,10)}function isNumber(value){return!isNaN(toInteger(value))}function padNumber(value){return isNumber(value)?(\"0\"+value).slice(-2):\"\"}},BJ2y:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return crud_table_module_CRUDTableModule});var paginator_model=__webpack_require__(\"+75Z\");__webpack_require__(\"2Vo4\"),__webpack_require__(\"LRne\"),__webpack_require__(\"JIr8\"),__webpack_require__(\"nYR2\"),__webpack_require__(\"vkgz\"),__webpack_require__(\"AytR\"),new paginator_model.b,new class{constructor(){this.column=\"id\",this.direction=\"asc\"}},new class{constructor(){this.selectedRowIds=new Set,this.itemIds=[]}checkAreAllRowsSelected(){return 0!==this.itemIds.length&&this.selectedRowIds.size===this.itemIds.length}selectRow(id){return this.selectedRowIds.has(id)?this.selectedRowIds.delete(id):this.selectedRowIds.add(id),this}clearRows(_itemIds){return this.itemIds=_itemIds,this.selectedRowIds=new Set,this}isRowSelected(id){return this.selectedRowIds.has(id)}selectAllRows(){return this.itemIds.length===this.selectedRowIds.size?this.selectedRowIds=new Set:(this.selectedRowIds=new Set,this.itemIds.forEach(id=>this.selectedRowIds.add(id))),this}getSelectedRows(){return Array.from(this.selectedRowIds)}getSelectedRowsCount(){return this.selectedRowIds.size}},__webpack_require__(\"tk/3\");var core=__webpack_require__(\"fXoL\"),common=__webpack_require__(\"ofXK\"),fesm2015_forms=__webpack_require__(\"3Pt+\"),lib_esmodule=__webpack_require__(\"e8Ap\");let crud_table_module_CRUDTableModule=(()=>{class CRUDTableModule{}return CRUDTableModule.ɵmod=core.Mb({type:CRUDTableModule}),CRUDTableModule.ɵinj=core.Lb({factory:function(t){return new(t||CRUDTableModule)},imports:[[common.c,fesm2015_forms.g,lib_esmodule.b]]}),CRUDTableModule})()},bSwM:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return checkbox_MatCheckbox}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return checkbox_MatCheckboxModule});var core=__webpack_require__(\"fXoL\");function coerceBooleanProperty(value){return null!=value&&\"\"+value!=\"false\"}function coerceNumberProperty(value,fallbackValue=0){return function(value){return!isNaN(parseFloat(value))&&!isNaN(Number(value))}(value)?Number(value):fallbackValue}function coerceElement(elementOrRef){return elementOrRef instanceof core.l?elementOrRef.nativeElement:elementOrRef}var fesm2015_forms=__webpack_require__(\"3Pt+\"),common=__webpack_require__(\"ofXK\"),Subject=__webpack_require__(\"XNiG\"),of=(__webpack_require__(\"quSY\"),__webpack_require__(\"LRne\"));__webpack_require__(\"vkgz\");var Subscriber=__webpack_require__(\"7o/Q\"),scheduler_async=__webpack_require__(\"D0XW\");class DebounceTimeOperator{constructor(dueTime,scheduler){this.dueTime=dueTime,this.scheduler=scheduler}call(subscriber,source){return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber,this.dueTime,this.scheduler))}}class debounceTime_DebounceTimeSubscriber extends Subscriber.a{constructor(destination,dueTime,scheduler){super(destination),this.dueTime=dueTime,this.scheduler=scheduler,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(value){this.clearDebounce(),this.lastValue=value,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(dispatchNext,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:lastValue}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(lastValue)}}clearDebounce(){const debouncedSubscription=this.debouncedSubscription;null!==debouncedSubscription&&(this.remove(debouncedSubscription),debouncedSubscription.unsubscribe(),this.debouncedSubscription=null)}}function dispatchNext(subscriber){subscriber.debouncedNext()}let hasV8BreakIterator;__webpack_require__(\"pLZG\"),__webpack_require__(\"lJxs\"),__webpack_require__(\"IzEk\");try{hasV8BreakIterator=\"undefined\"!=typeof Intl&&Intl.v8BreakIterator}catch(_a){hasV8BreakIterator=!1}let supportsPassiveEvents,shadowDomIsSupported,platform_Platform=(()=>{class Platform{constructor(_platformId){this._platformId=_platformId,this.isBrowser=this._platformId?Object(common.y)(this._platformId):\"object\"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!hasV8BreakIterator)&&\"undefined\"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!(\"MSStream\"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return Platform.ɵfac=function(t){return new(t||Platform)(core.bc(core.D))},Platform.ɵprov=Object(core.Kb)({factory:function(){return new Platform(Object(core.bc)(core.D))},token:Platform,providedIn:\"root\"}),Platform})(),platform_PlatformModule=(()=>{class PlatformModule{}return PlatformModule.ɵmod=core.Mb({type:PlatformModule}),PlatformModule.ɵinj=core.Lb({factory:function(t){return new(t||PlatformModule)}}),PlatformModule})();function normalizePassiveListenerOptions(options){return function(){if(null==supportsPassiveEvents&&\"undefined\"!=typeof window)try{window.addEventListener(\"test\",null,Object.defineProperty({},\"passive\",{get:()=>supportsPassiveEvents=!0}))}finally{supportsPassiveEvents=supportsPassiveEvents||!1}return supportsPassiveEvents}()?options:!!options.capture}var Observable=__webpack_require__(\"HDdC\");let observers_MutationObserverFactory=(()=>{class MutationObserverFactory{create(callback){return\"undefined\"==typeof MutationObserver?null:new MutationObserver(callback)}}return MutationObserverFactory.ɵfac=function(t){return new(t||MutationObserverFactory)},MutationObserverFactory.ɵprov=Object(core.Kb)({factory:function(){return new MutationObserverFactory},token:MutationObserverFactory,providedIn:\"root\"}),MutationObserverFactory})(),observers_ContentObserver=(()=>{class ContentObserver{constructor(_mutationObserverFactory){this._mutationObserverFactory=_mutationObserverFactory,this._observedElements=new Map}ngOnDestroy(){this._observedElements.forEach((_,element)=>this._cleanupObserver(element))}observe(elementOrRef){const element=coerceElement(elementOrRef);return new Observable.a(observer=>{const subscription=this._observeElement(element).subscribe(observer);return()=>{subscription.unsubscribe(),this._unobserveElement(element)}})}_observeElement(element){if(this._observedElements.has(element))this._observedElements.get(element).count++;else{const stream=new Subject.a,observer=this._mutationObserverFactory.create(mutations=>stream.next(mutations));observer&&observer.observe(element,{characterData:!0,childList:!0,subtree:!0}),this._observedElements.set(element,{observer:observer,stream:stream,count:1})}return this._observedElements.get(element).stream}_unobserveElement(element){this._observedElements.has(element)&&(this._observedElements.get(element).count--,this._observedElements.get(element).count||this._cleanupObserver(element))}_cleanupObserver(element){if(this._observedElements.has(element)){const{observer:observer,stream:stream}=this._observedElements.get(element);observer&&observer.disconnect(),stream.complete(),this._observedElements.delete(element)}}}return ContentObserver.ɵfac=function(t){return new(t||ContentObserver)(core.bc(observers_MutationObserverFactory))},ContentObserver.ɵprov=Object(core.Kb)({factory:function(){return new ContentObserver(Object(core.bc)(observers_MutationObserverFactory))},token:ContentObserver,providedIn:\"root\"}),ContentObserver})(),observers_CdkObserveContent=(()=>{class CdkObserveContent{constructor(_contentObserver,_elementRef,_ngZone){this._contentObserver=_contentObserver,this._elementRef=_elementRef,this._ngZone=_ngZone,this.event=new core.n,this._disabled=!1,this._currentSubscription=null}get disabled(){return this._disabled}set disabled(value){this._disabled=coerceBooleanProperty(value),this._disabled?this._unsubscribe():this._subscribe()}get debounce(){return this._debounce}set debounce(value){this._debounce=coerceNumberProperty(value),this._subscribe()}ngAfterContentInit(){this._currentSubscription||this.disabled||this._subscribe()}ngOnDestroy(){this._unsubscribe()}_subscribe(){this._unsubscribe();const stream=this._contentObserver.observe(this._elementRef);this._ngZone.runOutsideAngular(()=>{this._currentSubscription=(this.debounce?stream.pipe(function(dueTime,scheduler=scheduler_async.a){return source=>source.lift(new DebounceTimeOperator(dueTime,scheduler))}(this.debounce)):stream).subscribe(this.event)})}_unsubscribe(){var _a;null===(_a=this._currentSubscription)||void 0===_a||_a.unsubscribe()}}return CdkObserveContent.ɵfac=function(t){return new(t||CdkObserveContent)(core.Ob(observers_ContentObserver),core.Ob(core.l),core.Ob(core.B))},CdkObserveContent.ɵdir=core.Jb({type:CdkObserveContent,selectors:[[\"\",\"cdkObserveContent\",\"\"]],inputs:{disabled:[\"cdkObserveContentDisabled\",\"disabled\"],debounce:\"debounce\"},outputs:{event:\"cdkObserveContent\"},exportAs:[\"cdkObserveContent\"]}),CdkObserveContent})(),observers_ObserversModule=(()=>{class ObserversModule{}return ObserversModule.ɵmod=core.Mb({type:ObserversModule}),ObserversModule.ɵinj=core.Lb({factory:function(t){return new(t||ObserversModule)},providers:[observers_MutationObserverFactory]}),ObserversModule})();function isFakeMousedownFromScreenReader(event){return 0===event.buttons}function isFakeTouchstartFromScreenReader(event){const touch=event.touches&&event.touches[0]||event.changedTouches&&event.changedTouches[0];return!(!touch||-1!==touch.identifier||null!=touch.radiusX&&1!==touch.radiusX||null!=touch.radiusY&&1!==touch.radiusY)}\"undefined\"!=typeof Element&&Element;const FOCUS_MONITOR_DEFAULT_OPTIONS=new core.r(\"cdk-focus-monitor-default-options\"),captureEventListenerOptions=normalizePassiveListenerOptions({passive:!0,capture:!0});let a11y_FocusMonitor=(()=>{class FocusMonitor{constructor(_ngZone,_platform,document,options){this._ngZone=_ngZone,this._platform=_platform,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue(\"keyboard\")},this._documentMousedownListener=event=>{if(!this._lastTouchTarget){const source=isFakeMousedownFromScreenReader(event)?\"keyboard\":\"mouse\";this._setOriginForCurrentEventQueue(source)}},this._documentTouchstartListener=event=>{isFakeTouchstartFromScreenReader(event)?this._lastTouchTarget||this._setOriginForCurrentEventQueue(\"keyboard\"):(null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=getTarget(event),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650))},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=event=>{const target=getTarget(event),handler=\"focus\"===event.type?this._onFocus:this._onBlur;for(let element=target;element;element=element.parentElement)handler.call(this,event,element)},this._document=document,this._detectionMode=(null==options?void 0:options.detectionMode)||0}monitor(element,checkChildren=!1){const nativeElement=coerceElement(element);if(!this._platform.isBrowser||1!==nativeElement.nodeType)return Object(of.a)(null);const rootNode=function(element){if(function(){if(null==shadowDomIsSupported){const head=\"undefined\"!=typeof document?document.head:null;shadowDomIsSupported=!(!head||!head.createShadowRoot&&!head.attachShadow)}return shadowDomIsSupported}()){const rootNode=element.getRootNode?element.getRootNode():null;if(\"undefined\"!=typeof ShadowRoot&&ShadowRoot&&rootNode instanceof ShadowRoot)return rootNode}return null}(nativeElement)||this._getDocument(),cachedInfo=this._elementInfo.get(nativeElement);if(cachedInfo)return checkChildren&&(cachedInfo.checkChildren=!0),cachedInfo.subject;const info={checkChildren:checkChildren,subject:new Subject.a,rootNode:rootNode};return this._elementInfo.set(nativeElement,info),this._registerGlobalListeners(info),info.subject}stopMonitoring(element){const nativeElement=coerceElement(element),elementInfo=this._elementInfo.get(nativeElement);elementInfo&&(elementInfo.subject.complete(),this._setClasses(nativeElement),this._elementInfo.delete(nativeElement),this._removeGlobalListeners(elementInfo))}focusVia(element,origin,options){const nativeElement=coerceElement(element);nativeElement===this._getDocument().activeElement?this._getClosestElementsInfo(nativeElement).forEach(([currentElement,info])=>this._originChanged(currentElement,origin,info)):(this._setOriginForCurrentEventQueue(origin),\"function\"==typeof nativeElement.focus&&nativeElement.focus(options))}ngOnDestroy(){this._elementInfo.forEach((_info,element)=>this.stopMonitoring(element))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(element,className,shouldSet){shouldSet?element.classList.add(className):element.classList.remove(className)}_getFocusOrigin(event){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(event)?\"touch\":\"program\"}_setClasses(element,origin){this._toggleClass(element,\"cdk-focused\",!!origin),this._toggleClass(element,\"cdk-touch-focused\",\"touch\"===origin),this._toggleClass(element,\"cdk-keyboard-focused\",\"keyboard\"===origin),this._toggleClass(element,\"cdk-mouse-focused\",\"mouse\"===origin),this._toggleClass(element,\"cdk-program-focused\",\"program\"===origin)}_setOriginForCurrentEventQueue(origin){this._ngZone.runOutsideAngular(()=>{this._origin=origin,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(event){const focusTarget=getTarget(event);return this._lastTouchTarget instanceof Node&&focusTarget instanceof Node&&(focusTarget===this._lastTouchTarget||focusTarget.contains(this._lastTouchTarget))}_onFocus(event,element){const elementInfo=this._elementInfo.get(element);elementInfo&&(elementInfo.checkChildren||element===getTarget(event))&&this._originChanged(element,this._getFocusOrigin(event),elementInfo)}_onBlur(event,element){const elementInfo=this._elementInfo.get(element);!elementInfo||elementInfo.checkChildren&&event.relatedTarget instanceof Node&&element.contains(event.relatedTarget)||(this._setClasses(element),this._emitOrigin(elementInfo.subject,null))}_emitOrigin(subject,origin){this._ngZone.run(()=>subject.next(origin))}_registerGlobalListeners(elementInfo){if(!this._platform.isBrowser)return;const rootNode=elementInfo.rootNode,rootNodeFocusListeners=this._rootNodeFocusListenerCount.get(rootNode)||0;rootNodeFocusListeners||this._ngZone.runOutsideAngular(()=>{rootNode.addEventListener(\"focus\",this._rootNodeFocusAndBlurListener,captureEventListenerOptions),rootNode.addEventListener(\"blur\",this._rootNodeFocusAndBlurListener,captureEventListenerOptions)}),this._rootNodeFocusListenerCount.set(rootNode,rootNodeFocusListeners+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const document=this._getDocument(),window=this._getWindow();document.addEventListener(\"keydown\",this._documentKeydownListener,captureEventListenerOptions),document.addEventListener(\"mousedown\",this._documentMousedownListener,captureEventListenerOptions),document.addEventListener(\"touchstart\",this._documentTouchstartListener,captureEventListenerOptions),window.addEventListener(\"focus\",this._windowFocusListener)})}_removeGlobalListeners(elementInfo){const rootNode=elementInfo.rootNode;if(this._rootNodeFocusListenerCount.has(rootNode)){const rootNodeFocusListeners=this._rootNodeFocusListenerCount.get(rootNode);rootNodeFocusListeners>1?this._rootNodeFocusListenerCount.set(rootNode,rootNodeFocusListeners-1):(rootNode.removeEventListener(\"focus\",this._rootNodeFocusAndBlurListener,captureEventListenerOptions),rootNode.removeEventListener(\"blur\",this._rootNodeFocusAndBlurListener,captureEventListenerOptions),this._rootNodeFocusListenerCount.delete(rootNode))}if(!--this._monitoredElementCount){const document=this._getDocument(),window=this._getWindow();document.removeEventListener(\"keydown\",this._documentKeydownListener,captureEventListenerOptions),document.removeEventListener(\"mousedown\",this._documentMousedownListener,captureEventListenerOptions),document.removeEventListener(\"touchstart\",this._documentTouchstartListener,captureEventListenerOptions),window.removeEventListener(\"focus\",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}_originChanged(element,origin,elementInfo){this._setClasses(element,origin),this._emitOrigin(elementInfo.subject,origin),this._lastFocusOrigin=origin}_getClosestElementsInfo(element){const results=[];return this._elementInfo.forEach((info,currentElement)=>{(currentElement===element||info.checkChildren&&currentElement.contains(element))&&results.push([currentElement,info])}),results}}return FocusMonitor.ɵfac=function(t){return new(t||FocusMonitor)(core.bc(core.B),core.bc(platform_Platform),core.bc(common.d,8),core.bc(FOCUS_MONITOR_DEFAULT_OPTIONS,8))},FocusMonitor.ɵprov=Object(core.Kb)({factory:function(){return new FocusMonitor(Object(core.bc)(core.B),Object(core.bc)(platform_Platform),Object(core.bc)(common.d,8),Object(core.bc)(FOCUS_MONITOR_DEFAULT_OPTIONS,8))},token:FocusMonitor,providedIn:\"root\"}),FocusMonitor})();function getTarget(event){return event.composedPath?event.composedPath()[0]:event.target}let a11y_HighContrastModeDetector=(()=>{class HighContrastModeDetector{constructor(_platform,document){this._platform=_platform,this._document=document}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const testElement=this._document.createElement(\"div\");testElement.style.backgroundColor=\"rgb(1,2,3)\",testElement.style.position=\"absolute\",this._document.body.appendChild(testElement);const documentWindow=this._document.defaultView||window,computedStyle=documentWindow&&documentWindow.getComputedStyle?documentWindow.getComputedStyle(testElement):null,computedColor=(computedStyle&&computedStyle.backgroundColor||\"\").replace(/ /g,\"\");switch(this._document.body.removeChild(testElement),computedColor){case\"rgb(0,0,0)\":return 2;case\"rgb(255,255,255)\":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const bodyClasses=this._document.body.classList;bodyClasses.remove(\"cdk-high-contrast-active\"),bodyClasses.remove(\"cdk-high-contrast-black-on-white\"),bodyClasses.remove(\"cdk-high-contrast-white-on-black\");const mode=this.getHighContrastMode();1===mode?(bodyClasses.add(\"cdk-high-contrast-active\"),bodyClasses.add(\"cdk-high-contrast-black-on-white\")):2===mode&&(bodyClasses.add(\"cdk-high-contrast-active\"),bodyClasses.add(\"cdk-high-contrast-white-on-black\"))}}}return HighContrastModeDetector.ɵfac=function(t){return new(t||HighContrastModeDetector)(core.bc(platform_Platform),core.bc(common.d))},HighContrastModeDetector.ɵprov=Object(core.Kb)({factory:function(){return new HighContrastModeDetector(Object(core.bc)(platform_Platform),Object(core.bc)(common.d))},token:HighContrastModeDetector,providedIn:\"root\"}),HighContrastModeDetector})(),bidi_BidiModule=(()=>{class BidiModule{}return BidiModule.ɵmod=core.Mb({type:BidiModule}),BidiModule.ɵinj=core.Lb({factory:function(t){return new(t||BidiModule)}}),BidiModule})();const VERSION=new core.Q(\"11.2.10\");__webpack_require__(\"JX91\");var animations=__webpack_require__(\"R1ws\");const VERSION$1=new core.Q(\"11.2.10\"),MATERIAL_SANITY_CHECKS=new core.r(\"mat-sanity-checks\",{providedIn:\"root\",factory:function(){return!0}});let SUPPORTS_INTL_API,core_MatCommonModule=(()=>{class MatCommonModule{constructor(highContrastModeDetector,sanityChecks,document){this._hasDoneGlobalChecks=!1,this._document=document,highContrastModeDetector._applyBodyHighContrastModeCssClasses(),this._sanityChecks=sanityChecks,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getWindow(){const win=this._document.defaultView||window;return\"object\"==typeof win&&win?win:null}_checksAreEnabled(){return Object(core.X)()&&!this._isTestEnv()}_isTestEnv(){const window=this._getWindow();return window&&(window.__karma__||window.jasmine)}_checkDoctypeIsDefined(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype)&&!this._document.doctype&&console.warn(\"Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.\")}_checkThemeIsPresent(){if(!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme||!this._document.body||\"function\"!=typeof getComputedStyle)return;const testElement=this._document.createElement(\"div\");testElement.classList.add(\"mat-theme-loaded-marker\"),this._document.body.appendChild(testElement);const computedStyle=getComputedStyle(testElement);computedStyle&&\"none\"!==computedStyle.display&&console.warn(\"Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming\"),this._document.body.removeChild(testElement)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&VERSION$1.full!==VERSION.full&&console.warn(\"The Angular Material version (\"+VERSION$1.full+\") does not match the Angular CDK version (\"+VERSION.full+\").\\nPlease ensure the versions of these two packages exactly match.\")}}return MatCommonModule.ɵmod=core.Mb({type:MatCommonModule}),MatCommonModule.ɵinj=core.Lb({factory:function(t){return new(t||MatCommonModule)(core.bc(a11y_HighContrastModeDetector),core.bc(MATERIAL_SANITY_CHECKS,8),core.bc(common.d))},imports:[[bidi_BidiModule],bidi_BidiModule]}),MatCommonModule})();function mixinDisabled(base){return class extends base{constructor(...args){super(...args),this._disabled=!1}get disabled(){return this._disabled}set disabled(value){this._disabled=coerceBooleanProperty(value)}}}function mixinColor(base,defaultColor){return class extends base{constructor(...args){super(...args),this.defaultColor=defaultColor,this.color=defaultColor}get color(){return this._color}set color(value){const colorPalette=value||this.defaultColor;colorPalette!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(\"mat-\"+this._color),colorPalette&&this._elementRef.nativeElement.classList.add(\"mat-\"+colorPalette),this._color=colorPalette)}}}function mixinDisableRipple(base){return class extends base{constructor(...args){super(...args),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(value){this._disableRipple=coerceBooleanProperty(value)}}}function mixinTabIndex(base,defaultTabIndex=0){return class extends base{constructor(...args){super(...args),this._tabIndex=defaultTabIndex,this.defaultTabIndex=defaultTabIndex}get tabIndex(){return this.disabled?-1:this._tabIndex}set tabIndex(value){this._tabIndex=null!=value?coerceNumberProperty(value):this.defaultTabIndex}}}try{SUPPORTS_INTL_API=\"undefined\"!=typeof Intl}catch(_a){SUPPORTS_INTL_API=!1}class RippleRef{constructor(_renderer,element,config){this._renderer=_renderer,this.element=element,this.config=config,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const defaultRippleAnimationConfig={enterDuration:450,exitDuration:400},passiveEventOptions=normalizePassiveListenerOptions({passive:!0}),pointerDownEvents=[\"mousedown\",\"touchstart\"],pointerUpEvents=[\"mouseup\",\"mouseleave\",\"touchend\",\"touchcancel\"];class core_RippleRenderer{constructor(_target,_ngZone,elementOrElementRef,platform){this._target=_target,this._ngZone=_ngZone,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,platform.isBrowser&&(this._containerElement=coerceElement(elementOrElementRef))}fadeInRipple(x,y,config={}){const containerRect=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),animationConfig=Object.assign(Object.assign({},defaultRippleAnimationConfig),config.animation);config.centered&&(x=containerRect.left+containerRect.width/2,y=containerRect.top+containerRect.height/2);const radius=config.radius||function(x,y,rect){const distX=Math.max(Math.abs(x-rect.left),Math.abs(x-rect.right)),distY=Math.max(Math.abs(y-rect.top),Math.abs(y-rect.bottom));return Math.sqrt(distX*distX+distY*distY)}(x,y,containerRect),offsetX=x-containerRect.left,offsetY=y-containerRect.top,duration=animationConfig.enterDuration,ripple=document.createElement(\"div\");ripple.classList.add(\"mat-ripple-element\"),ripple.style.left=offsetX-radius+\"px\",ripple.style.top=offsetY-radius+\"px\",ripple.style.height=2*radius+\"px\",ripple.style.width=2*radius+\"px\",null!=config.color&&(ripple.style.backgroundColor=config.color),ripple.style.transitionDuration=duration+\"ms\",this._containerElement.appendChild(ripple),window.getComputedStyle(ripple).getPropertyValue(\"opacity\"),ripple.style.transform=\"scale(1)\";const rippleRef=new RippleRef(this,ripple,config);return rippleRef.state=0,this._activeRipples.add(rippleRef),config.persistent||(this._mostRecentTransientRipple=rippleRef),this._runTimeoutOutsideZone(()=>{const isMostRecentTransientRipple=rippleRef===this._mostRecentTransientRipple;rippleRef.state=1,config.persistent||isMostRecentTransientRipple&&this._isPointerDown||rippleRef.fadeOut()},duration),rippleRef}fadeOutRipple(rippleRef){const wasActive=this._activeRipples.delete(rippleRef);if(rippleRef===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!wasActive)return;const rippleEl=rippleRef.element,animationConfig=Object.assign(Object.assign({},defaultRippleAnimationConfig),rippleRef.config.animation);rippleEl.style.transitionDuration=animationConfig.exitDuration+\"ms\",rippleEl.style.opacity=\"0\",rippleRef.state=2,this._runTimeoutOutsideZone(()=>{rippleRef.state=3,rippleEl.parentNode.removeChild(rippleEl)},animationConfig.exitDuration)}fadeOutAll(){this._activeRipples.forEach(ripple=>ripple.fadeOut())}setupTriggerEvents(elementOrElementRef){const element=coerceElement(elementOrElementRef);element&&element!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=element,this._registerEvents(pointerDownEvents))}handleEvent(event){\"mousedown\"===event.type?this._onMousedown(event):\"touchstart\"===event.type?this._onTouchStart(event):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(pointerUpEvents),this._pointerUpEventsRegistered=!0)}_onMousedown(event){const isFakeMousedown=isFakeMousedownFromScreenReader(event),isSyntheticEvent=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||isFakeMousedown||isSyntheticEvent||(this._isPointerDown=!0,this.fadeInRipple(event.clientX,event.clientY,this._target.rippleConfig))}_onTouchStart(event){if(!this._target.rippleDisabled&&!isFakeTouchstartFromScreenReader(event)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const touches=event.changedTouches;for(let i=0;i<touches.length;i++)this.fadeInRipple(touches[i].clientX,touches[i].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(ripple=>{!ripple.config.persistent&&(1===ripple.state||ripple.config.terminateOnPointerUp&&0===ripple.state)&&ripple.fadeOut()}))}_runTimeoutOutsideZone(fn,delay=0){this._ngZone.runOutsideAngular(()=>setTimeout(fn,delay))}_registerEvents(eventTypes){this._ngZone.runOutsideAngular(()=>{eventTypes.forEach(type=>{this._triggerElement.addEventListener(type,this,passiveEventOptions)})})}_removeTriggerEvents(){this._triggerElement&&(pointerDownEvents.forEach(type=>{this._triggerElement.removeEventListener(type,this,passiveEventOptions)}),this._pointerUpEventsRegistered&&pointerUpEvents.forEach(type=>{this._triggerElement.removeEventListener(type,this,passiveEventOptions)}))}}const MAT_RIPPLE_GLOBAL_OPTIONS=new core.r(\"mat-ripple-global-options\");let core_MatRipple=(()=>{class MatRipple{constructor(_elementRef,ngZone,platform,globalOptions,_animationMode){this._elementRef=_elementRef,this._animationMode=_animationMode,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=globalOptions||{},this._rippleRenderer=new core_RippleRenderer(this,ngZone,_elementRef,platform)}get disabled(){return this._disabled}set disabled(value){this._disabled=value,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(trigger){this._trigger=trigger,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),\"NoopAnimations\"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(configOrX,y=0,config){return\"number\"==typeof configOrX?this._rippleRenderer.fadeInRipple(configOrX,y,Object.assign(Object.assign({},this.rippleConfig),config)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),configOrX))}}return MatRipple.ɵfac=function(t){return new(t||MatRipple)(core.Ob(core.l),core.Ob(core.B),core.Ob(platform_Platform),core.Ob(MAT_RIPPLE_GLOBAL_OPTIONS,8),core.Ob(animations.a,8))},MatRipple.ɵdir=core.Jb({type:MatRipple,selectors:[[\"\",\"mat-ripple\",\"\"],[\"\",\"matRipple\",\"\"]],hostAttrs:[1,\"mat-ripple\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Gb(\"mat-ripple-unbounded\",ctx.unbounded)},inputs:{radius:[\"matRippleRadius\",\"radius\"],disabled:[\"matRippleDisabled\",\"disabled\"],trigger:[\"matRippleTrigger\",\"trigger\"],color:[\"matRippleColor\",\"color\"],unbounded:[\"matRippleUnbounded\",\"unbounded\"],centered:[\"matRippleCentered\",\"centered\"],animation:[\"matRippleAnimation\",\"animation\"]},exportAs:[\"matRipple\"]}),MatRipple})(),core_MatRippleModule=(()=>{class MatRippleModule{}return MatRippleModule.ɵmod=core.Mb({type:MatRippleModule}),MatRippleModule.ɵinj=core.Lb({factory:function(t){return new(t||MatRippleModule)},imports:[[core_MatCommonModule,platform_PlatformModule],core_MatCommonModule]}),MatRippleModule})();const checkbox_c0=[\"input\"],checkbox_c1=function(){return{enterDuration:150}},checkbox_c2=[\"*\"],MAT_CHECKBOX_DEFAULT_OPTIONS=new core.r(\"mat-checkbox-default-options\",{providedIn:\"root\",factory:MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY});function MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY(){return{color:\"accent\",clickAction:\"check-indeterminate\"}}let nextUniqueId=0;const defaults=MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY(),MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR={provide:fesm2015_forms.i,useExisting:Object(core.V)(()=>checkbox_MatCheckbox),multi:!0};class MatCheckboxChange{}class MatCheckboxBase{constructor(_elementRef){this._elementRef=_elementRef}}const _MatCheckboxMixinBase=mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatCheckboxBase))));let checkbox_MatCheckbox=(()=>{class MatCheckbox extends _MatCheckboxMixinBase{constructor(elementRef,_changeDetectorRef,_focusMonitor,_ngZone,tabIndex,_animationMode,_options){super(elementRef),this._changeDetectorRef=_changeDetectorRef,this._focusMonitor=_focusMonitor,this._ngZone=_ngZone,this._animationMode=_animationMode,this._options=_options,this.ariaLabel=\"\",this.ariaLabelledby=null,this._uniqueId=\"mat-checkbox-\"+ ++nextUniqueId,this.id=this._uniqueId,this.labelPosition=\"after\",this.name=null,this.change=new core.n,this.indeterminateChange=new core.n,this._onTouched=()=>{},this._currentAnimationClass=\"\",this._currentCheckState=0,this._controlValueAccessorChangeFn=()=>{},this._checked=!1,this._disabled=!1,this._indeterminate=!1,this._options=this._options||defaults,this.color=this.defaultColor=this._options.color||defaults.color,this.tabIndex=parseInt(tabIndex)||0}get inputId(){return(this.id||this._uniqueId)+\"-input\"}get required(){return this._required}set required(value){this._required=coerceBooleanProperty(value)}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0).subscribe(focusOrigin=>{focusOrigin||Promise.resolve().then(()=>{this._onTouched(),this._changeDetectorRef.markForCheck()})}),this._syncIndeterminate(this._indeterminate)}ngAfterViewChecked(){}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}get checked(){return this._checked}set checked(value){value!=this.checked&&(this._checked=value,this._changeDetectorRef.markForCheck())}get disabled(){return this._disabled}set disabled(value){const newValue=coerceBooleanProperty(value);newValue!==this.disabled&&(this._disabled=newValue,this._changeDetectorRef.markForCheck())}get indeterminate(){return this._indeterminate}set indeterminate(value){const changed=value!=this._indeterminate;this._indeterminate=coerceBooleanProperty(value),changed&&(this._transitionCheckState(this._indeterminate?3:this.checked?1:2),this.indeterminateChange.emit(this._indeterminate)),this._syncIndeterminate(this._indeterminate)}_isRippleDisabled(){return this.disableRipple||this.disabled}_onLabelTextChange(){this._changeDetectorRef.detectChanges()}writeValue(value){this.checked=!!value}registerOnChange(fn){this._controlValueAccessorChangeFn=fn}registerOnTouched(fn){this._onTouched=fn}setDisabledState(isDisabled){this.disabled=isDisabled}_getAriaChecked(){return this.checked?\"true\":this.indeterminate?\"mixed\":\"false\"}_transitionCheckState(newState){let oldState=this._currentCheckState,element=this._elementRef.nativeElement;if(oldState!==newState&&(this._currentAnimationClass.length>0&&element.classList.remove(this._currentAnimationClass),this._currentAnimationClass=this._getAnimationClassForCheckStateTransition(oldState,newState),this._currentCheckState=newState,this._currentAnimationClass.length>0)){element.classList.add(this._currentAnimationClass);const animationClass=this._currentAnimationClass;this._ngZone.runOutsideAngular(()=>{setTimeout(()=>{element.classList.remove(animationClass)},1e3)})}}_emitChangeEvent(){const event=new MatCheckboxChange;event.source=this,event.checked=this.checked,this._controlValueAccessorChangeFn(this.checked),this.change.emit(event),this._inputElement&&(this._inputElement.nativeElement.checked=this.checked)}toggle(){this.checked=!this.checked}_onInputClick(event){var _a;const clickAction=null===(_a=this._options)||void 0===_a?void 0:_a.clickAction;event.stopPropagation(),this.disabled||\"noop\"===clickAction?this.disabled||\"noop\"!==clickAction||(this._inputElement.nativeElement.checked=this.checked,this._inputElement.nativeElement.indeterminate=this.indeterminate):(this.indeterminate&&\"check\"!==clickAction&&Promise.resolve().then(()=>{this._indeterminate=!1,this.indeterminateChange.emit(this._indeterminate)}),this.toggle(),this._transitionCheckState(this._checked?1:2),this._emitChangeEvent())}focus(origin,options){origin?this._focusMonitor.focusVia(this._inputElement,origin,options):this._inputElement.nativeElement.focus(options)}_onInteractionEvent(event){event.stopPropagation()}_getAnimationClassForCheckStateTransition(oldState,newState){if(\"NoopAnimations\"===this._animationMode)return\"\";let animSuffix=\"\";switch(oldState){case 0:if(1===newState)animSuffix=\"unchecked-checked\";else{if(3!=newState)return\"\";animSuffix=\"unchecked-indeterminate\"}break;case 2:animSuffix=1===newState?\"unchecked-checked\":\"unchecked-indeterminate\";break;case 1:animSuffix=2===newState?\"checked-unchecked\":\"checked-indeterminate\";break;case 3:animSuffix=1===newState?\"indeterminate-checked\":\"indeterminate-unchecked\"}return\"mat-checkbox-anim-\"+animSuffix}_syncIndeterminate(value){const nativeCheckbox=this._inputElement;nativeCheckbox&&(nativeCheckbox.nativeElement.indeterminate=value)}}return MatCheckbox.ɵfac=function(t){return new(t||MatCheckbox)(core.Ob(core.l),core.Ob(core.h),core.Ob(a11y_FocusMonitor),core.Ob(core.B),core.cc(\"tabindex\"),core.Ob(animations.a,8),core.Ob(MAT_CHECKBOX_DEFAULT_OPTIONS,8))},MatCheckbox.ɵcmp=core.Ib({type:MatCheckbox,selectors:[[\"mat-checkbox\"]],viewQuery:function(rf,ctx){if(1&rf&&(core.Mc(checkbox_c0,!0),core.Mc(core_MatRipple,!0)),2&rf){let _t;core.vc(_t=core.fc())&&(ctx._inputElement=_t.first),core.vc(_t=core.fc())&&(ctx.ripple=_t.first)}},hostAttrs:[1,\"mat-checkbox\"],hostVars:12,hostBindings:function(rf,ctx){2&rf&&(core.Xb(\"id\",ctx.id),core.Db(\"tabindex\",null),core.Gb(\"mat-checkbox-indeterminate\",ctx.indeterminate)(\"mat-checkbox-checked\",ctx.checked)(\"mat-checkbox-disabled\",ctx.disabled)(\"mat-checkbox-label-before\",\"before\"==ctx.labelPosition)(\"_mat-animation-noopable\",\"NoopAnimations\"===ctx._animationMode))},inputs:{disableRipple:\"disableRipple\",color:\"color\",tabIndex:\"tabIndex\",ariaLabel:[\"aria-label\",\"ariaLabel\"],ariaLabelledby:[\"aria-labelledby\",\"ariaLabelledby\"],id:\"id\",labelPosition:\"labelPosition\",name:\"name\",required:\"required\",checked:\"checked\",disabled:\"disabled\",indeterminate:\"indeterminate\",ariaDescribedby:[\"aria-describedby\",\"ariaDescribedby\"],value:\"value\"},outputs:{change:\"change\",indeterminateChange:\"indeterminateChange\"},exportAs:[\"matCheckbox\"],features:[core.Bb([MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR]),core.zb],ngContentSelectors:checkbox_c2,decls:17,vars:20,consts:[[1,\"mat-checkbox-layout\"],[\"label\",\"\"],[1,\"mat-checkbox-inner-container\"],[\"type\",\"checkbox\",1,\"mat-checkbox-input\",\"cdk-visually-hidden\",3,\"id\",\"required\",\"checked\",\"disabled\",\"tabIndex\",\"change\",\"click\"],[\"input\",\"\"],[\"matRipple\",\"\",1,\"mat-checkbox-ripple\",\"mat-focus-indicator\",3,\"matRippleTrigger\",\"matRippleDisabled\",\"matRippleRadius\",\"matRippleCentered\",\"matRippleAnimation\"],[1,\"mat-ripple-element\",\"mat-checkbox-persistent-ripple\"],[1,\"mat-checkbox-frame\"],[1,\"mat-checkbox-background\"],[\"version\",\"1.1\",\"focusable\",\"false\",\"viewBox\",\"0 0 24 24\",0,\"xml\",\"space\",\"preserve\",1,\"mat-checkbox-checkmark\"],[\"fill\",\"none\",\"stroke\",\"white\",\"d\",\"M4.1,12.7 9,17.6 20.3,6.3\",1,\"mat-checkbox-checkmark-path\"],[1,\"mat-checkbox-mixedmark\"],[1,\"mat-checkbox-label\",3,\"cdkObserveContent\"],[\"checkboxLabel\",\"\"],[2,\"display\",\"none\"]],template:function(rf,ctx){if(1&rf&&(core.nc(),core.Ub(0,\"label\",0,1),core.Ub(2,\"span\",2),core.Ub(3,\"input\",3,4),core.ec(\"change\",function($event){return ctx._onInteractionEvent($event)})(\"click\",function($event){return ctx._onInputClick($event)}),core.Tb(),core.Ub(5,\"span\",5),core.Pb(6,\"span\",6),core.Tb(),core.Pb(7,\"span\",7),core.Ub(8,\"span\",8),core.hc(),core.Ub(9,\"svg\",9),core.Pb(10,\"path\",10),core.Tb(),core.gc(),core.Pb(11,\"span\",11),core.Tb(),core.Tb(),core.Ub(12,\"span\",12,13),core.ec(\"cdkObserveContent\",function(){return ctx._onLabelTextChange()}),core.Ub(14,\"span\",14),core.Hc(15,\" \"),core.Tb(),core.mc(16),core.Tb(),core.Tb()),2&rf){const _r0=core.wc(1),_r2=core.wc(13);core.Db(\"for\",ctx.inputId),core.Cb(2),core.Gb(\"mat-checkbox-inner-container-no-side-margin\",!_r2.textContent||!_r2.textContent.trim()),core.Cb(1),core.oc(\"id\",ctx.inputId)(\"required\",ctx.required)(\"checked\",ctx.checked)(\"disabled\",ctx.disabled)(\"tabIndex\",ctx.tabIndex),core.Db(\"value\",ctx.value)(\"name\",ctx.name)(\"aria-label\",ctx.ariaLabel||null)(\"aria-labelledby\",ctx.ariaLabelledby)(\"aria-checked\",ctx._getAriaChecked())(\"aria-describedby\",ctx.ariaDescribedby),core.Cb(2),core.oc(\"matRippleTrigger\",_r0)(\"matRippleDisabled\",ctx._isRippleDisabled())(\"matRippleRadius\",20)(\"matRippleCentered\",!0)(\"matRippleAnimation\",core.rc(19,checkbox_c1))}},directives:[core_MatRipple,observers_CdkObserveContent],styles:[\"@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.910259}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);stroke-dashoffset:0}to{stroke-dashoffset:-22.910259}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0deg)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}32.8%,100%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{display:inline-block;transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}.cdk-high-contrast-active .mat-checkbox.cdk-keyboard-focused .mat-checkbox-frame{border-style:dotted}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0, 0, 0.2, 0.1),opacity 90ms cubic-bezier(0, 0, 0.2, 0.1);-webkit-print-color-adjust:exact;color-adjust:exact}._mat-animation-noopable .mat-checkbox-background{transition:none}.cdk-high-contrast-active .mat-checkbox .mat-checkbox-background{background:none}.mat-checkbox-persistent-ripple{display:block;width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media(hover: none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.910259;stroke-dasharray:22.910259;stroke-width:2.1333333333px}.cdk-high-contrast-black-on-white .mat-checkbox-checkmark-path{stroke:#000 !important}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0deg);border-radius:2px}.cdk-high-contrast-active .mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0deg)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.cdk-high-contrast-active .mat-checkbox-disabled{opacity:.5}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0ms mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0ms mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:300ms linear 0ms mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}\\n\"],encapsulation:2,changeDetection:0}),MatCheckbox})(),checkbox_MatCheckboxRequiredValidatorModule=(()=>{class _MatCheckboxRequiredValidatorModule{}return _MatCheckboxRequiredValidatorModule.ɵmod=core.Mb({type:_MatCheckboxRequiredValidatorModule}),_MatCheckboxRequiredValidatorModule.ɵinj=core.Lb({factory:function(t){return new(t||_MatCheckboxRequiredValidatorModule)}}),_MatCheckboxRequiredValidatorModule})(),checkbox_MatCheckboxModule=(()=>{class MatCheckboxModule{}return MatCheckboxModule.ɵmod=core.Mb({type:MatCheckboxModule}),MatCheckboxModule.ɵinj=core.Lb({factory:function(t){return new(t||MatCheckboxModule)},imports:[[core_MatRippleModule,core_MatCommonModule,observers_ObserversModule,checkbox_MatCheckboxRequiredValidatorModule],core_MatCommonModule,checkbox_MatCheckboxRequiredValidatorModule]}),MatCheckboxModule})()},\"jT/F\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return UploadService});var rxjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"z6cu\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"JIr8\"),src_environments_environment__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"AytR\"),_angular_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"fXoL\"),_angular_common_http__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"tk/3\");let UploadService=(()=>{class UploadService{constructor(http){this.http=http,this.API_URL=src_environments_environment__WEBPACK_IMPORTED_MODULE_2__.a.apiUrl+\"api/Upload\"}uploadImagen(file){const formData=new FormData;return formData.append(\"file\",file,file.name),this.http.post(this.API_URL+\"?carpeta=imagenes\",formData,{reportProgress:!0,observe:\"events\"}).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(this.errorMgmt))}uploadDocumento(file){const formData=new FormData;return formData.append(\"file\",file,file.name),this.http.post(this.API_URL+\"?carpeta=documentos\",formData,{reportProgress:!0,observe:\"events\"}).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(this.errorMgmt))}errorMgmt(error){let errorMessage=\"\";return errorMessage=error.error instanceof ErrorEvent?error.error.message:`Error Code: ${error.status}\\nMessage: ${error.message}`,console.log(errorMessage),Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(()=>errorMessage)}}return UploadService.ɵfac=function(t){return new(t||UploadService)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.bc(_angular_common_http__WEBPACK_IMPORTED_MODULE_4__.c))},UploadService.ɵprov=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Kb({token:UploadService,factory:UploadService.ɵfac,providedIn:\"root\"}),UploadService})()}}]);","name":"3-es2015.1137afc6d454af7bd363.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[3],{\n\n/***/ \"+75Z\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PageSizes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return PaginatorState; });\nconst PageSizes = [3, 5, 10, 15, 50, 100];\nclass PaginatorState {\n    constructor() {\n        this.page = 1;\n        this.pageSize = PageSizes[2];\n        this.total = 0;\n        this.pageSizes = [];\n    }\n    recalculatePaginator(total) {\n        this.total = total;\n        return this;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"4NA8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return NgbDateCustomParserFormatter; });\n/* unused harmony export toInteger */\n/* unused harmony export isNumber */\n/* unused harmony export padNumber */\n/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"1kSV\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"fXoL\");\n\r\n\r\nlet NgbDateCustomParserFormatter = /*@__PURE__*/ (() => {\r\n    class NgbDateCustomParserFormatter extends _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_0__[/* NgbDateParserFormatter */ \"c\"] {\r\n        parse(value) {\r\n            if (value) {\r\n                const dateParts = value.trim().split(\"/\");\r\n                if (dateParts.length === 1 && isNumber(dateParts[0])) {\r\n                    return { day: toInteger(dateParts[0]), month: null, year: null };\r\n                }\r\n                else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {\r\n                    return {\r\n                        day: toInteger(dateParts[0]),\r\n                        month: toInteger(dateParts[1]),\r\n                        year: null\r\n                    };\r\n                }\r\n                else if (dateParts.length === 3 && isNumber(dateParts[0]) && isNumber(dateParts[1]) && isNumber(dateParts[2])) {\r\n                    return {\r\n                        day: toInteger(dateParts[0]),\r\n                        month: toInteger(dateParts[1]),\r\n                        year: toInteger(dateParts[2])\r\n                    };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        format(date) {\r\n            return date\r\n                ? `${isNumber(date.day) ? padNumber(date.day) : \"\"}/${isNumber(date.month) ? padNumber(date.month) : \"\"}/${date.year}`\r\n                : \"\";\r\n        }\r\n    }\r\n    NgbDateCustomParserFormatter.ɵfac = function NgbDateCustomParserFormatter_Factory(t) { return ɵNgbDateCustomParserFormatter_BaseFactory(t || NgbDateCustomParserFormatter); };\r\n    NgbDateCustomParserFormatter.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[/* ɵɵdefineInjectable */ \"Kb\"]({ token: NgbDateCustomParserFormatter, factory: NgbDateCustomParserFormatter.ɵfac });\r\n    return NgbDateCustomParserFormatter;\r\n})();\r\nconst ɵNgbDateCustomParserFormatter_BaseFactory = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_1__[/* ɵɵgetInheritedFactory */ \"Wb\"](NgbDateCustomParserFormatter);\r\nfunction toInteger(value) {\r\n    return parseInt(`${value}`, 10);\r\n}\r\nfunction isNumber(value) {\r\n    return !isNaN(toInteger(value));\r\n}\r\nfunction padNumber(value) {\r\n    if (isNumber(value)) {\r\n        return `0${value}`.slice(-2);\r\n    }\r\n    else {\r\n        return \"\";\r\n    }\r\n}\r\n\n\n/***/ }),\n\n/***/ \"BJ2y\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* reexport */ crud_table_module_CRUDTableModule; });\n\n// UNUSED EXPORTS: SortState, PageSizes, PaginatorState, GroupingState, TableService, TableExtendedService\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/models/table.model.ts\n\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/models/sort.model.ts\nclass SortState {\n    constructor() {\n        this.column = 'id'; // Id by default\n        this.direction = 'asc'; // asc by default;\n    }\n}\n\n// EXTERNAL MODULE: ./src/app/_metronic_gestion/shared/crud-table/models/paginator.model.ts\nvar paginator_model = __webpack_require__(\"+75Z\");\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/models/grouping.model.ts\nclass GroupingState {\n    constructor() {\n        this.selectedRowIds = new Set();\n        this.itemIds = [];\n    }\n    checkAreAllRowsSelected() {\n        if (this.itemIds.length === 0) {\n            return false;\n        }\n        return this.selectedRowIds.size === this.itemIds.length;\n    }\n    selectRow(id) {\n        if (this.selectedRowIds.has(id)) {\n            this.selectedRowIds.delete(id);\n        }\n        else {\n            this.selectedRowIds.add(id);\n        }\n        return this;\n    }\n    // tslint:disable-next-line:variable-name\n    clearRows(_itemIds) {\n        this.itemIds = _itemIds;\n        this.selectedRowIds = new Set();\n        return this;\n    }\n    isRowSelected(id) {\n        return this.selectedRowIds.has(id);\n    }\n    selectAllRows() {\n        const areAllSelected = this.itemIds.length === this.selectedRowIds.size;\n        if (areAllSelected) {\n            this.selectedRowIds = new Set();\n        }\n        else {\n            this.selectedRowIds = new Set();\n            this.itemIds.forEach(id => this.selectedRowIds.add(id));\n        }\n        return this;\n    }\n    getSelectedRows() {\n        return Array.from(this.selectedRowIds);\n    }\n    getSelectedRowsCount() {\n        return this.selectedRowIds.size;\n    }\n}\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/models/search.model.ts\n\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/models/filter.model.ts\n\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js\nvar BehaviorSubject = __webpack_require__(\"2Vo4\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/catchError.js\nvar catchError = __webpack_require__(\"JIr8\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/finalize.js\nvar finalize = __webpack_require__(\"nYR2\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js\nvar tap = __webpack_require__(\"vkgz\");\n\n// EXTERNAL MODULE: ./src/environments/environment.ts\nvar environment = __webpack_require__(\"AytR\");\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/services/table.service.ts\n\n\n\n\n\n\nconst DEFAULT_STATE = {\n    filter: {},\n    paginator: new paginator_model[\"b\" /* PaginatorState */](),\n    sorting: new SortState(),\n    searchTerm: '',\n    grouping: new GroupingState(),\n    entityId: undefined\n};\nclass table_service_TableService {\n    constructor(http) {\n        // Private fields\n        this._items$ = new BehaviorSubject[\"a\" /* BehaviorSubject */]([]);\n        this._isLoading$ = new BehaviorSubject[\"a\" /* BehaviorSubject */](false);\n        this._isFirstLoading$ = new BehaviorSubject[\"a\" /* BehaviorSubject */](true);\n        this._tableState$ = new BehaviorSubject[\"a\" /* BehaviorSubject */](DEFAULT_STATE);\n        this._errorMessage = new BehaviorSubject[\"a\" /* BehaviorSubject */]('');\n        this._subscriptions = [];\n        // API URL has to be overrided\n        this.API_URL = `${environment[\"a\" /* environment */].apiUrl}/endpoint`;\n        this.http = http;\n    }\n    // Getters\n    get items$() {\n        return this._items$.asObservable();\n    }\n    get isLoading$() {\n        return this._isLoading$.asObservable();\n    }\n    get isFirstLoading$() {\n        return this._isFirstLoading$.asObservable();\n    }\n    get errorMessage$() {\n        return this._errorMessage.asObservable();\n    }\n    get subscriptions() {\n        return this._subscriptions;\n    }\n    // State getters\n    get paginator() {\n        return this._tableState$.value.paginator;\n    }\n    get filter() {\n        return this._tableState$.value.filter;\n    }\n    get sorting() {\n        return this._tableState$.value.sorting;\n    }\n    get searchTerm() {\n        return this._tableState$.value.searchTerm;\n    }\n    get grouping() {\n        return this._tableState$.value.grouping;\n    }\n    // CREATE\n    // server should return the object with ID\n    create(item) {\n        this._isLoading$.next(true);\n        this._errorMessage.next('');\n        return this.http.post(this.API_URL, item).pipe(Object(catchError[\"a\" /* catchError */])(err => {\n            this._errorMessage.next(err);\n            console.error('CREATE ITEM', err);\n            return Object(of[\"a\" /* of */])({ id: undefined });\n        }), Object(finalize[\"a\" /* finalize */])(() => this._isLoading$.next(false)));\n    }\n    // READ (Returning filtered list of entities)\n    find(tableState) {\n        const url = this.API_URL + '/find';\n        this._errorMessage.next('');\n        return this.http.post(url, tableState).pipe(Object(catchError[\"a\" /* catchError */])(err => {\n            this._errorMessage.next(err);\n            console.error('FIND ITEMS', err);\n            return Object(of[\"a\" /* of */])({ items: [], total: 0 });\n        }));\n    }\n    getItemById(id) {\n        this._isLoading$.next(true);\n        this._errorMessage.next('');\n        const url = `${this.API_URL}/${id}`;\n        return this.http.get(url).pipe(Object(catchError[\"a\" /* catchError */])(err => {\n            this._errorMessage.next(err);\n            console.error('GET ITEM BY IT', id, err);\n            return Object(of[\"a\" /* of */])({ id: undefined });\n        }), Object(finalize[\"a\" /* finalize */])(() => this._isLoading$.next(false)));\n    }\n    // UPDATE\n    update(item) {\n        const url = `${this.API_URL}/${item.id}`;\n        this._isLoading$.next(true);\n        this._errorMessage.next('');\n        return this.http.put(url, item).pipe(Object(catchError[\"a\" /* catchError */])(err => {\n            this._errorMessage.next(err);\n            console.error('UPDATE ITEM', item, err);\n            return Object(of[\"a\" /* of */])(item);\n        }), Object(finalize[\"a\" /* finalize */])(() => this._isLoading$.next(false)));\n    }\n    // UPDATE Status\n    updateStatusForItems(ids, status) {\n        this._isLoading$.next(true);\n        this._errorMessage.next('');\n        const body = { ids, status };\n        const url = this.API_URL + '/updateStatus';\n        return this.http.put(url, body).pipe(Object(catchError[\"a\" /* catchError */])(err => {\n            this._errorMessage.next(err);\n            console.error('UPDATE STATUS FOR SELECTED ITEMS', ids, status, err);\n            return Object(of[\"a\" /* of */])([]);\n        }), Object(finalize[\"a\" /* finalize */])(() => this._isLoading$.next(false)));\n    }\n    // DELETE\n    delete(id) {\n        this._isLoading$.next(true);\n        this._errorMessage.next('');\n        const url = `${this.API_URL}/${id}`;\n        return this.http.delete(url).pipe(Object(catchError[\"a\" /* catchError */])(err => {\n            this._errorMessage.next(err);\n            console.error('DELETE ITEM', id, err);\n            return Object(of[\"a\" /* of */])({});\n        }), Object(finalize[\"a\" /* finalize */])(() => this._isLoading$.next(false)));\n    }\n    // delete list of items\n    deleteItems(ids = []) {\n        this._isLoading$.next(true);\n        this._errorMessage.next('');\n        const url = this.API_URL + '/deleteItems';\n        const body = { ids };\n        return this.http.put(url, body).pipe(Object(catchError[\"a\" /* catchError */])(err => {\n            this._errorMessage.next(err);\n            console.error('DELETE SELECTED ITEMS', ids, err);\n            return Object(of[\"a\" /* of */])([]);\n        }), Object(finalize[\"a\" /* finalize */])(() => this._isLoading$.next(false)));\n    }\n    fetch() {\n        this._isLoading$.next(true);\n        this._errorMessage.next('');\n        const request = this.find(this._tableState$.value)\n            .pipe(Object(tap[\"a\" /* tap */])((res) => {\n            this._items$.next(res.items);\n            this.patchStateWithoutFetch({\n                paginator: this._tableState$.value.paginator.recalculatePaginator(res.total),\n            });\n        }), Object(catchError[\"a\" /* catchError */])((err) => {\n            this._errorMessage.next(err);\n            return Object(of[\"a\" /* of */])({\n                items: [],\n                total: 0\n            });\n        }), Object(finalize[\"a\" /* finalize */])(() => {\n            this._isLoading$.next(false);\n            const itemIds = this._items$.value.map((el) => {\n                const item = el;\n                return item.id;\n            });\n            this.patchStateWithoutFetch({\n                grouping: this._tableState$.value.grouping.clearRows(itemIds),\n            });\n        }))\n            .subscribe();\n        this._subscriptions.push(request);\n    }\n    setDefaults() {\n        this.patchStateWithoutFetch({ filter: {} });\n        this.patchStateWithoutFetch({ sorting: new SortState() });\n        this.patchStateWithoutFetch({ grouping: new GroupingState() });\n        this.patchStateWithoutFetch({ searchTerm: '' });\n        this.patchStateWithoutFetch({\n            paginator: new paginator_model[\"b\" /* PaginatorState */]()\n        });\n        this._isFirstLoading$.next(true);\n        this._isLoading$.next(true);\n        this._tableState$.next(DEFAULT_STATE);\n        this._errorMessage.next('');\n    }\n    // Base Methods\n    patchState(patch) {\n        this.patchStateWithoutFetch(patch);\n        this.fetch();\n    }\n    patchStateWithoutFetch(patch) {\n        const newState = Object.assign(this._tableState$.value, patch);\n        this._tableState$.next(newState);\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js\nvar fesm2015_http = __webpack_require__(\"tk/3\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/services/table.extended.service.ts\n\r\n\r\n\r\nlet table_extended_service_TableExtendedService = /*@__PURE__*/ (() => {\r\n    class TableExtendedService extends table_service_TableService {\r\n        constructor(http) {\r\n            super(http);\r\n        }\r\n    }\r\n    TableExtendedService.ɵfac = function TableExtendedService_Factory(t) { return new (t || TableExtendedService)(core[\"bc\" /* ɵɵinject */](fesm2015_http[\"c\" /* HttpClient */])); };\r\n    TableExtendedService.ɵprov = core[\"Kb\" /* ɵɵdefineInjectable */]({ token: TableExtendedService, factory: TableExtendedService.ɵfac, providedIn: 'root' });\r\n    return TableExtendedService;\r\n})();\r\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js\nvar fesm2015_forms = __webpack_require__(\"3Pt+\");\n\n// EXTERNAL MODULE: ./node_modules/ng-inline-svg/__ivy_ngcc__/lib_esmodule/index.js + 7 modules\nvar lib_esmodule = __webpack_require__(\"e8Ap\");\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/crud-table.module.ts\n\r\n\r\n\r\n\r\nlet crud_table_module_CRUDTableModule = /*@__PURE__*/ (() => {\r\n    class CRUDTableModule {\r\n    }\r\n    CRUDTableModule.ɵmod = core[\"Mb\" /* ɵɵdefineNgModule */]({ type: CRUDTableModule });\r\n    CRUDTableModule.ɵinj = core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function CRUDTableModule_Factory(t) { return new (t || CRUDTableModule)(); }, imports: [[common[\"c\" /* CommonModule */], fesm2015_forms[\"g\" /* FormsModule */], lib_esmodule[\"b\" /* InlineSVGModule */]]] });\r\n    return CRUDTableModule;\r\n})();\r\n\n// CONCATENATED MODULE: ./src/app/_metronic_gestion/shared/crud-table/index.ts\n// Models\n\n\n\n\n\n\n// Directives\n// Services\n\n\n// Module\n\n\n\n/***/ }),\n\n/***/ \"bSwM\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ checkbox_MatCheckbox; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ checkbox_MatCheckboxModule; });\n\n// UNUSED EXPORTS: MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, MAT_CHECKBOX_DEFAULT_OPTIONS, MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckboxChange, MatCheckboxRequiredValidator, _MatCheckboxRequiredValidatorModule\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a data-bound value (typically a string) to a boolean. */\nfunction coerceBooleanProperty(value) {\n    return value != null && `${value}` !== 'false';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a value to a CSS pixel value. */\nfunction coerceCssPixelValue(value) {\n    if (value == null) {\n        return '';\n    }\n    return typeof value === 'string' ? value : `${value}px`;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nfunction coerceElement(elementOrRef) {\n    return elementOrRef instanceof core[\"l\" /* ElementRef */] ? elementOrRef.nativeElement : elementOrRef;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces a value to an array of trimmed non-empty strings.\n * Any input that is not an array, `null` or `undefined` will be turned into a string\n * via `toString()` and subsequently split with the given separator.\n * `null` and `undefined` will result in an empty array.\n * This results in the following outcomes:\n * - `null` -&gt; `[]`\n * - `[null]` -&gt; `[\"null\"]`\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\n *\n * Useful for defining CSS classes or table columns.\n * @param value the value to coerce into an array of strings\n * @param separator split-separator if value isn't an array\n */\nfunction coerceStringArray(value, separator = /\\s+/) {\n    const result = [];\n    if (value != null) {\n        const sourceValues = Array.isArray(value) ? value : `${value}`.split(separator);\n        for (const sourceValue of sourceValues) {\n            const trimmedString = `${sourceValue}`.trim();\n            if (trimmedString) {\n                result.push(trimmedString);\n            }\n        }\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//# sourceMappingURL=coercion.js.map\n\n// EXTERNAL MODULE: ./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js\nvar fesm2015_forms = __webpack_require__(\"3Pt+\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/keycodes.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAC_ENTER = 3;\nconst BACKSPACE = 8;\nconst TAB = 9;\nconst NUM_CENTER = 12;\nconst ENTER = 13;\nconst SHIFT = 16;\nconst CONTROL = 17;\nconst ALT = 18;\nconst PAUSE = 19;\nconst CAPS_LOCK = 20;\nconst ESCAPE = 27;\nconst SPACE = 32;\nconst PAGE_UP = 33;\nconst PAGE_DOWN = 34;\nconst END = 35;\nconst HOME = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\nconst PLUS_SIGN = 43;\nconst PRINT_SCREEN = 44;\nconst INSERT = 45;\nconst DELETE = 46;\nconst ZERO = 48;\nconst ONE = 49;\nconst TWO = 50;\nconst THREE = 51;\nconst FOUR = 52;\nconst FIVE = 53;\nconst SIX = 54;\nconst SEVEN = 55;\nconst EIGHT = 56;\nconst NINE = 57;\nconst FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nconst FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nconst QUESTION_MARK = 63;\nconst AT_SIGN = 64;\nconst A = 65;\nconst B = 66;\nconst C = 67;\nconst D = 68;\nconst E = 69;\nconst F = 70;\nconst G = 71;\nconst H = 72;\nconst I = 73;\nconst J = 74;\nconst K = 75;\nconst L = 76;\nconst M = 77;\nconst N = 78;\nconst O = 79;\nconst P = 80;\nconst Q = 81;\nconst R = 82;\nconst S = 83;\nconst T = 84;\nconst U = 85;\nconst V = 86;\nconst W = 87;\nconst X = 88;\nconst Y = 89;\nconst Z = 90;\nconst META = 91; // WIN_KEY_LEFT\nconst MAC_WK_CMD_LEFT = 91;\nconst MAC_WK_CMD_RIGHT = 93;\nconst CONTEXT_MENU = 93;\nconst NUMPAD_ZERO = 96;\nconst NUMPAD_ONE = 97;\nconst NUMPAD_TWO = 98;\nconst NUMPAD_THREE = 99;\nconst NUMPAD_FOUR = 100;\nconst NUMPAD_FIVE = 101;\nconst NUMPAD_SIX = 102;\nconst NUMPAD_SEVEN = 103;\nconst NUMPAD_EIGHT = 104;\nconst NUMPAD_NINE = 105;\nconst NUMPAD_MULTIPLY = 106;\nconst NUMPAD_PLUS = 107;\nconst NUMPAD_MINUS = 109;\nconst NUMPAD_PERIOD = 110;\nconst NUMPAD_DIVIDE = 111;\nconst F1 = 112;\nconst F2 = 113;\nconst F3 = 114;\nconst F4 = 115;\nconst F5 = 116;\nconst F6 = 117;\nconst F7 = 118;\nconst F8 = 119;\nconst F9 = 120;\nconst F10 = 121;\nconst F11 = 122;\nconst F12 = 123;\nconst NUM_LOCK = 144;\nconst SCROLL_LOCK = 145;\nconst FIRST_MEDIA = 166;\nconst FF_MINUS = 173;\nconst MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nconst VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nconst VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nconst FF_MUTE = 181;\nconst FF_VOLUME_DOWN = 182;\nconst LAST_MEDIA = 183;\nconst FF_VOLUME_UP = 183;\nconst SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nconst EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nconst COMMA = 188;\nconst DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nconst PERIOD = 190;\nconst SLASH = 191;\nconst APOSTROPHE = 192;\nconst TILDE = 192;\nconst OPEN_SQUARE_BRACKET = 219;\nconst BACKSLASH = 220;\nconst CLOSE_SQUARE_BRACKET = 221;\nconst SINGLE_QUOTE = 222;\nconst MAC_META = 224;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n    if (modifiers.length) {\n        return modifiers.some(modifier => event[modifier]);\n    }\n    return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=keycodes.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js\nvar tap = __webpack_require__(\"vkgz\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js\nvar Subscriber = __webpack_require__(\"7o/Q\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js\nvar scheduler_async = __webpack_require__(\"D0XW\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js\n\n\nfunction debounceTime(dueTime, scheduler = scheduler_async[\"a\" /* async */]) {\n    return (source) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nclass DebounceTimeOperator {\n    constructor(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    }\n}\nclass debounceTime_DebounceTimeSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, dueTime, scheduler) {\n        super(destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    }\n    _complete() {\n        this.debouncedNext();\n        this.destination.complete();\n    }\n    debouncedNext() {\n        this.clearDebounce();\n        if (this.hasValue) {\n            const { lastValue } = this;\n            this.lastValue = null;\n            this.hasValue = false;\n            this.destination.next(lastValue);\n        }\n    }\n    clearDebounce() {\n        const debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    }\n}\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js\nvar filter = __webpack_require__(\"pLZG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js\nvar take = __webpack_require__(\"IzEk\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\n\nlet hasV8BreakIterator;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\n}\ncatch (_a) {\n    hasV8BreakIterator = false;\n}\nlet platform_Platform = /*@__PURE__*/ (() => {\n    class Platform {\n        constructor(_platformId) {\n            this._platformId = _platformId;\n            // We want to use the Angular platform check because if the Document is shimmed\n            // without the navigator, the following checks will fail. This is preferred because\n            // sometimes the Document may be shimmed without the user's knowledge or intention\n            /** Whether the Angular application is being rendered in the browser. */\n            this.isBrowser = this._platformId ?\n                Object(common[\"y\" /* isPlatformBrowser */])(this._platformId) : typeof document === 'object' && !!document;\n            /** Whether the current browser is Microsoft Edge. */\n            this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n            /** Whether the current rendering engine is Microsoft Trident. */\n            this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n            // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n            /** Whether the current rendering engine is Blink. */\n            this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\n                typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n            // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n            // ensure that Webkit runs standalone and is not used as another engine's base.\n            /** Whether the current rendering engine is WebKit. */\n            this.WEBKIT = this.isBrowser &&\n                /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n            /** Whether the current platform is Apple iOS. */\n            this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n                !('MSStream' in window);\n            // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n            // them self as Gecko-like browsers and modify the userAgent's according to that.\n            // Since we only cover one explicit Firefox case, we can simply check for Firefox\n            // instead of having an unstable check for Gecko.\n            /** Whether the current browser is Firefox. */\n            this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n            /** Whether the current platform is Android. */\n            // Trident on mobile adds the android platform to the userAgent to trick detections.\n            this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n            // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n            // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n            // Safari browser should also use Webkit as its layout engine.\n            /** Whether the current browser is Safari. */\n            this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n        }\n    }\n    Platform.ɵfac = function Platform_Factory(t) { return new (t || Platform)(core[\"bc\" /* ɵɵinject */](core[\"D\" /* PLATFORM_ID */])); };\n    Platform.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function Platform_Factory() { return new Platform(Object(core[\"bc\" /* ɵɵinject */])(core[\"D\" /* PLATFORM_ID */])); }, token: Platform, providedIn: \"root\" });\n    return Platform;\n})();\nlet platform_PlatformModule = /*@__PURE__*/ (() => {\n    class PlatformModule {\n    }\n    PlatformModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: PlatformModule });\n    PlatformModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function PlatformModule_Factory(t) { return new (t || PlatformModule)(); } });\n    return PlatformModule;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/** @returns The input types supported by this browser. */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    let featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => supportsPassiveEvents = true\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\nfunction supportsScrollBehavior() {\n    if (scrollBehaviorSupported == null) {\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\n        // some projects stub out the global `document` during SSR which can throw us off.\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n            scrollBehaviorSupported = false;\n            return scrollBehaviorSupported;\n        }\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n        if ('scrollBehavior' in document.documentElement.style) {\n            scrollBehaviorSupported = true;\n        }\n        else {\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n            const scrollToFunction = Element.prototype.scrollTo;\n            if (scrollToFunction) {\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                // polyfilled functions as supporting scroll behavior.\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n            }\n            else {\n                scrollBehaviorSupported = false;\n            }\n        }\n    }\n    return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nfunction getRtlScrollAxisType() {\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n    if (typeof document !== 'object' || !document) {\n        return 0 /* NORMAL */;\n    }\n    if (rtlScrollAxisType == null) {\n        // Create a 1px wide scrolling container and a 2px wide content element.\n        const scrollContainer = document.createElement('div');\n        const containerStyle = scrollContainer.style;\n        scrollContainer.dir = 'rtl';\n        containerStyle.width = '1px';\n        containerStyle.overflow = 'auto';\n        containerStyle.visibility = 'hidden';\n        containerStyle.pointerEvents = 'none';\n        containerStyle.position = 'absolute';\n        const content = document.createElement('div');\n        const contentStyle = content.style;\n        contentStyle.width = '2px';\n        contentStyle.height = '1px';\n        scrollContainer.appendChild(content);\n        document.body.appendChild(scrollContainer);\n        rtlScrollAxisType = 0 /* NORMAL */;\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n        // dealing with one of the other two types of browsers.\n        if (scrollContainer.scrollLeft === 0) {\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n            // return 0 when we read it again.\n            scrollContainer.scrollLeft = 1;\n            rtlScrollAxisType =\n                scrollContainer.scrollLeft === 0 ? 1 /* NEGATED */ : 2 /* INVERTED */;\n        }\n        scrollContainer.parentNode.removeChild(scrollContainer);\n    }\n    return rtlScrollAxisType;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=platform.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 3 modules\nvar Observable = __webpack_require__(\"HDdC\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/observers.js\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\n\nlet observers_MutationObserverFactory = /*@__PURE__*/ (() => {\n    class MutationObserverFactory {\n        create(callback) {\n            return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n        }\n    }\n    MutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t) { return new (t || MutationObserverFactory)(); };\n    MutationObserverFactory.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\n    return MutationObserverFactory;\n})();\nlet observers_ContentObserver = /*@__PURE__*/ (() => {\n    class ContentObserver {\n        constructor(_mutationObserverFactory) {\n            this._mutationObserverFactory = _mutationObserverFactory;\n            /** Keeps track of the existing MutationObservers so they can be reused. */\n            this._observedElements = new Map();\n        }\n        ngOnDestroy() {\n            this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n        }\n        observe(elementOrRef) {\n            const element = coerceElement(elementOrRef);\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                const stream = this._observeElement(element);\n                const subscription = stream.subscribe(observer);\n                return () => {\n                    subscription.unsubscribe();\n                    this._unobserveElement(element);\n                };\n            });\n        }\n        /**\n         * Observes the given element by using the existing MutationObserver if available, or creating a\n         * new one if not.\n         */\n        _observeElement(element) {\n            if (!this._observedElements.has(element)) {\n                const stream = new Subject[\"a\" /* Subject */]();\n                const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n                if (observer) {\n                    observer.observe(element, {\n                        characterData: true,\n                        childList: true,\n                        subtree: true\n                    });\n                }\n                this._observedElements.set(element, { observer, stream, count: 1 });\n            }\n            else {\n                this._observedElements.get(element).count++;\n            }\n            return this._observedElements.get(element).stream;\n        }\n        /**\n         * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n         * observing this element.\n         */\n        _unobserveElement(element) {\n            if (this._observedElements.has(element)) {\n                this._observedElements.get(element).count--;\n                if (!this._observedElements.get(element).count) {\n                    this._cleanupObserver(element);\n                }\n            }\n        }\n        /** Clean up the underlying MutationObserver for the specified element. */\n        _cleanupObserver(element) {\n            if (this._observedElements.has(element)) {\n                const { observer, stream } = this._observedElements.get(element);\n                if (observer) {\n                    observer.disconnect();\n                }\n                stream.complete();\n                this._observedElements.delete(element);\n            }\n        }\n    }\n    ContentObserver.ɵfac = function ContentObserver_Factory(t) { return new (t || ContentObserver)(core[\"bc\" /* ɵɵinject */](observers_MutationObserverFactory)); };\n    ContentObserver.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function ContentObserver_Factory() { return new ContentObserver(Object(core[\"bc\" /* ɵɵinject */])(observers_MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\n    return ContentObserver;\n})();\nlet observers_CdkObserveContent = /*@__PURE__*/ (() => {\n    class CdkObserveContent {\n        constructor(_contentObserver, _elementRef, _ngZone) {\n            this._contentObserver = _contentObserver;\n            this._elementRef = _elementRef;\n            this._ngZone = _ngZone;\n            /** Event emitted for each change in the element's content. */\n            this.event = new core[\"n\" /* EventEmitter */]();\n            this._disabled = false;\n            this._currentSubscription = null;\n        }\n        /**\n         * Whether observing content is disabled. This option can be used\n         * to disconnect the underlying MutationObserver until it is needed.\n         */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            this._disabled = coerceBooleanProperty(value);\n            this._disabled ? this._unsubscribe() : this._subscribe();\n        }\n        /** Debounce interval for emitting the changes. */\n        get debounce() { return this._debounce; }\n        set debounce(value) {\n            this._debounce = coerceNumberProperty(value);\n            this._subscribe();\n        }\n        ngAfterContentInit() {\n            if (!this._currentSubscription && !this.disabled) {\n                this._subscribe();\n            }\n        }\n        ngOnDestroy() {\n            this._unsubscribe();\n        }\n        _subscribe() {\n            this._unsubscribe();\n            const stream = this._contentObserver.observe(this._elementRef);\n            // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\n            // Consider brining it back inside the zone next time we're making breaking changes.\n            // Bringing it back inside can cause things like infinite change detection loops and changed\n            // after checked errors if people's code isn't handling it properly.\n            this._ngZone.runOutsideAngular(() => {\n                this._currentSubscription =\n                    (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\n            });\n        }\n        _unsubscribe() {\n            var _a;\n            (_a = this._currentSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        }\n    }\n    CdkObserveContent.ɵfac = function CdkObserveContent_Factory(t) { return new (t || CdkObserveContent)(core[\"Ob\" /* ɵɵdirectiveInject */](observers_ContentObserver), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    CdkObserveContent.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: CdkObserveContent, selectors: [[\"\", \"cdkObserveContent\", \"\"]], inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\"], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"] });\n    return CdkObserveContent;\n})();\nlet observers_ObserversModule = /*@__PURE__*/ (() => {\n    class ObserversModule {\n    }\n    ObserversModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: ObserversModule });\n    ObserversModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function ObserversModule_Factory(t) { return new (t || ObserversModule)(); }, providers: [observers_MutationObserverFactory] });\n    return ObserversModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](observers_ObserversModule, { declarations: [observers_CdkObserveContent], exports: [observers_CdkObserveContent] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=observers.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/a11y.js\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IDs are delimited by an empty space, as per the spec. */\n\n\n\nconst ID_DELIMITER = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction addAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    if (ids.some(existingId => existingId.trim() == id.trim())) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    const filteredIds = ids.filter(val => val != id.trim());\n    if (filteredIds.length) {\n        el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n    }\n    else {\n        el.removeAttribute(attr);\n    }\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace delimited) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** ID used for the body container where all messages are appended. */\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/** ID prefix used for each created message element. */\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/** Attribute given to each host element that is described by a message element. */\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n/** Global map of all registered message elements that have been placed into the document. */\nconst messageRegistry = /*@__PURE__*/ new Map();\n/** Container for all registered messages. */\nlet messagesContainer = null;\nlet a11y_AriaDescriber = /*@__PURE__*/ (() => {\n    class AriaDescriber {\n        constructor(_document) {\n            this._document = _document;\n        }\n        describe(hostElement, message, role) {\n            if (!this._canBeDescribed(hostElement, message)) {\n                return;\n            }\n            const key = getKey(message, role);\n            if (typeof message !== 'string') {\n                // We need to ensure that the element has an ID.\n                setMessageId(message);\n                messageRegistry.set(key, { messageElement: message, referenceCount: 0 });\n            }\n            else if (!messageRegistry.has(key)) {\n                this._createMessageElement(message, role);\n            }\n            if (!this._isElementDescribedByMessage(hostElement, key)) {\n                this._addMessageReference(hostElement, key);\n            }\n        }\n        removeDescription(hostElement, message, role) {\n            if (!message || !this._isElementNode(hostElement)) {\n                return;\n            }\n            const key = getKey(message, role);\n            if (this._isElementDescribedByMessage(hostElement, key)) {\n                this._removeMessageReference(hostElement, key);\n            }\n            // If the message is a string, it means that it's one that we created for the\n            // consumer so we can remove it safely, otherwise we should leave it in place.\n            if (typeof message === 'string') {\n                const registeredMessage = messageRegistry.get(key);\n                if (registeredMessage && registeredMessage.referenceCount === 0) {\n                    this._deleteMessageElement(key);\n                }\n            }\n            if (messagesContainer && messagesContainer.childNodes.length === 0) {\n                this._deleteMessagesContainer();\n            }\n        }\n        /** Unregisters all created message elements and removes the message container. */\n        ngOnDestroy() {\n            const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}]`);\n            for (let i = 0; i < describedElements.length; i++) {\n                this._removeCdkDescribedByReferenceIds(describedElements[i]);\n                describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n            }\n            if (messagesContainer) {\n                this._deleteMessagesContainer();\n            }\n            messageRegistry.clear();\n        }\n        /**\n         * Creates a new element in the visually hidden message container element with the message\n         * as its content and adds it to the message registry.\n         */\n        _createMessageElement(message, role) {\n            const messageElement = this._document.createElement('div');\n            setMessageId(messageElement);\n            messageElement.textContent = message;\n            if (role) {\n                messageElement.setAttribute('role', role);\n            }\n            this._createMessagesContainer();\n            messagesContainer.appendChild(messageElement);\n            messageRegistry.set(getKey(message, role), { messageElement, referenceCount: 0 });\n        }\n        /** Deletes the message element from the global messages container. */\n        _deleteMessageElement(key) {\n            const registeredMessage = messageRegistry.get(key);\n            const messageElement = registeredMessage && registeredMessage.messageElement;\n            if (messagesContainer && messageElement) {\n                messagesContainer.removeChild(messageElement);\n            }\n            messageRegistry.delete(key);\n        }\n        /** Creates the global container for all aria-describedby messages. */\n        _createMessagesContainer() {\n            if (!messagesContainer) {\n                const preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n                // When going from the server to the client, we may end up in a situation where there's\n                // already a container on the page, but we don't have a reference to it. Clear the\n                // old container so we don't get duplicates. Doing this, instead of emptying the previous\n                // container, should be slightly faster.\n                if (preExistingContainer && preExistingContainer.parentNode) {\n                    preExistingContainer.parentNode.removeChild(preExistingContainer);\n                }\n                messagesContainer = this._document.createElement('div');\n                messagesContainer.id = MESSAGES_CONTAINER_ID;\n                // We add `visibility: hidden` in order to prevent text in this container from\n                // being searchable by the browser's Ctrl + F functionality.\n                // Screen-readers will still read the description for elements with aria-describedby even\n                // when the description element is not visible.\n                messagesContainer.style.visibility = 'hidden';\n                // Even though we use `visibility: hidden`, we still apply `cdk-visually-hidden` so that\n                // the description element doesn't impact page layout.\n                messagesContainer.classList.add('cdk-visually-hidden');\n                this._document.body.appendChild(messagesContainer);\n            }\n        }\n        /** Deletes the global messages container. */\n        _deleteMessagesContainer() {\n            if (messagesContainer && messagesContainer.parentNode) {\n                messagesContainer.parentNode.removeChild(messagesContainer);\n                messagesContainer = null;\n            }\n        }\n        /** Removes all cdk-describedby messages that are hosted through the element. */\n        _removeCdkDescribedByReferenceIds(element) {\n            // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n            const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n                .filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n            element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n        }\n        /**\n         * Adds a message reference to the element using aria-describedby and increments the registered\n         * message's reference count.\n         */\n        _addMessageReference(element, key) {\n            const registeredMessage = messageRegistry.get(key);\n            // Add the aria-describedby reference and set the\n            // describedby_host attribute to mark the element.\n            addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n            registeredMessage.referenceCount++;\n        }\n        /**\n         * Removes a message reference from the element using aria-describedby\n         * and decrements the registered message's reference count.\n         */\n        _removeMessageReference(element, key) {\n            const registeredMessage = messageRegistry.get(key);\n            registeredMessage.referenceCount--;\n            removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        /** Returns true if the element has been described by the provided message ID. */\n        _isElementDescribedByMessage(element, key) {\n            const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n            const registeredMessage = messageRegistry.get(key);\n            const messageId = registeredMessage && registeredMessage.messageElement.id;\n            return !!messageId && referenceIds.indexOf(messageId) != -1;\n        }\n        /** Determines whether a message can be described on a particular element. */\n        _canBeDescribed(element, message) {\n            if (!this._isElementNode(element)) {\n                return false;\n            }\n            if (message && typeof message === 'object') {\n                // We'd have to make some assumptions about the description element's text, if the consumer\n                // passed in an element. Assume that if an element is passed in, the consumer has verified\n                // that it can be used as a description.\n                return true;\n            }\n            const trimmedMessage = message == null ? '' : `${message}`.trim();\n            const ariaLabel = element.getAttribute('aria-label');\n            // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n            // element, because screen readers will end up reading out the same text twice in a row.\n            return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\n        }\n        /** Checks whether a node is an Element node. */\n        _isElementNode(element) {\n            return element.nodeType === this._document.ELEMENT_NODE;\n        }\n    }\n    AriaDescriber.ɵfac = function AriaDescriber_Factory(t) { return new (t || AriaDescriber)(core[\"bc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */])); };\n    AriaDescriber.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function AriaDescriber_Factory() { return new AriaDescriber(Object(core[\"bc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */])); }, token: AriaDescriber, providedIn: \"root\" });\n    return AriaDescriber;\n})();\n/** Gets a key that can be used to look messages up in the registry. */\nfunction getKey(message, role) {\n    return typeof message === 'string' ? `${role || ''}/${message}` : message;\n}\n/** Assigns a unique ID to an element, if it doesn't have one already. */\nfunction setMessageId(element) {\n    if (!element.id) {\n        element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${nextId++}`;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass a11y_ListKeyManager {\n    constructor(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._activeItem = null;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"a\" /* Subject */]();\n        this._typeaheadSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        this._vertical = true;\n        this._allowedModifierKeys = [];\n        this._homeAndEnd = false;\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = (item) => item.disabled;\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"a\" /* Subject */]();\n        /** Stream that emits whenever the active item of the list manager changes. */\n        this.change = new Subject[\"a\" /* Subject */]();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof core[\"F\" /* QueryList */]) {\n            _items.changes.subscribe((newItems) => {\n                if (this._activeItem) {\n                    const itemArray = newItems.toArray();\n                    const newIndex = itemArray.indexOf(this._activeItem);\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                        this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && (this._items.length &&\n            this._items.some(item => typeof item.getLabel !== 'function'))) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"a\" /* tap */])(letter => this._pressedLetters.push(letter)), debounceTime(debounceInterval), Object(filter[\"a\" /* filter */])(() => this._pressedLetters.length > 0), Object(map[\"a\" /* map */])(() => this._pressedLetters.join(''))).subscribe(inputString => {\n            const items = this._getItemsArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n                if (!this._skipPredicateFn(item) &&\n                    item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n            this._pressedLetters = [];\n        });\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem;\n        this.updateActiveItem(item);\n        if (this._activeItem !== previousActiveItem) {\n            this.change.next(this._activeItemIndex);\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                    if (event.key && event.key.length === 1) {\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                    }\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\n                    }\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex;\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem;\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return this._pressedLetters.length > 0;\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem = activeItem == null ? null : activeItem;\n        this._activeItemIndex = index;\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        return this._items instanceof core[\"F\" /* QueryList */] ? this._items.toArray() : this._items;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ActiveDescendantKeyManager extends a11y_ListKeyManager {\n    setActiveItem(index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        super.setActiveItem(index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass FocusKeyManager extends a11y_ListKeyManager {\n    constructor() {\n        super(...arguments);\n        this._origin = 'program';\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    setActiveItem(item) {\n        super.setActiveItem(item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for the isFocusable method.\n */\nclass IsFocusableConfig {\n    constructor() {\n        /**\n         * Whether to count an element as focusable even if it is not currently visible.\n         */\n        this.ignoreVisibility = false;\n    }\n}\nlet a11y_InteractivityChecker = /*@__PURE__*/ (() => {\n    class InteractivityChecker {\n        constructor(_platform) {\n            this._platform = _platform;\n        }\n        /**\n         * Gets whether an element is disabled.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is disabled.\n         */\n        isDisabled(element) {\n            // This does not capture some cases, such as a non-form control with a disabled attribute or\n            // a form control inside of a disabled form, but should capture the most common cases.\n            return element.hasAttribute('disabled');\n        }\n        /**\n         * Gets whether an element is visible for the purposes of interactivity.\n         *\n         * This will capture states like `display: none` and `visibility: hidden`, but not things like\n         * being clipped by an `overflow: hidden` parent or being outside the viewport.\n         *\n         * @returns Whether the element is visible.\n         */\n        isVisible(element) {\n            return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n        }\n        /**\n         * Gets whether an element can be reached via Tab key.\n         * Assumes that the element has already been checked with isFocusable.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is tabbable.\n         */\n        isTabbable(element) {\n            // Nothing is tabbable on the server 😎\n            if (!this._platform.isBrowser) {\n                return false;\n            }\n            const frameElement = getFrameElement(getWindow(element));\n            if (frameElement) {\n                // Frame elements inherit their tabindex onto all child elements.\n                if (getTabIndexValue(frameElement) === -1) {\n                    return false;\n                }\n                // Browsers disable tabbing to an element inside of an invisible frame.\n                if (!this.isVisible(frameElement)) {\n                    return false;\n                }\n            }\n            let nodeName = element.nodeName.toLowerCase();\n            let tabIndexValue = getTabIndexValue(element);\n            if (element.hasAttribute('contenteditable')) {\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'iframe' || nodeName === 'object') {\n                // The frame or object's content may be tabbable depending on the content, but it's\n                // not possibly to reliably detect the content of the frames. We always consider such\n                // elements as non-tabbable.\n                return false;\n            }\n            // In iOS, the browser only considers some specific elements as tabbable.\n            if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n                return false;\n            }\n            if (nodeName === 'audio') {\n                // Audio elements without controls enabled are never tabbable, regardless\n                // of the tabindex attribute explicitly being set.\n                if (!element.hasAttribute('controls')) {\n                    return false;\n                }\n                // Audio elements with controls are by default tabbable unless the\n                // tabindex attribute is set to `-1` explicitly.\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'video') {\n                // For all video elements, if the tabindex attribute is set to `-1`, the video\n                // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n                // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n                // tabindex attribute is the source of truth here.\n                if (tabIndexValue === -1) {\n                    return false;\n                }\n                // If the tabindex is explicitly set, and not `-1` (as per check before), the\n                // video element is always tabbable (regardless of whether it has controls or not).\n                if (tabIndexValue !== null) {\n                    return true;\n                }\n                // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n                // has controls enabled. Firefox is special as videos are always tabbable regardless\n                // of whether there are controls or not.\n                return this._platform.FIREFOX || element.hasAttribute('controls');\n            }\n            return element.tabIndex >= 0;\n        }\n        /**\n         * Gets whether an element can be focused by the user.\n         *\n         * @param element Element to be checked.\n         * @param config The config object with options to customize this method's behavior\n         * @returns Whether the element is focusable.\n         */\n        isFocusable(element, config) {\n            // Perform checks in order of left to most expensive.\n            // Again, naive approach that does not capture many edge cases and browser quirks.\n            return isPotentiallyFocusable(element) && !this.isDisabled(element) &&\n                ((config === null || config === void 0 ? void 0 : config.ignoreVisibility) || this.isVisible(element));\n        }\n    }\n    InteractivityChecker.ɵfac = function InteractivityChecker_Factory(t) { return new (t || InteractivityChecker)(core[\"bc\" /* ɵɵinject */](platform_Platform)); };\n    InteractivityChecker.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(Object(core[\"bc\" /* ɵɵinject */])(platform_Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\n    return InteractivityChecker;\n})();\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch (_a) {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return node.ownerDocument && node.ownerDocument.defaultView || window;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n *\n * @deprecated Use `ConfigurableFocusTrap` instead.\n * @breaking-change 11.0.0\n */\nclass a11y_FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n        this.startAnchorListener = () => this.focusLastTabbableElement();\n        this.endAnchorListener = () => this.focusFirstTabbableElement();\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Whether the focus trap is active. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            if (startAnchor.parentNode) {\n                startAnchor.parentNode.removeChild(startAnchor);\n            }\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            if (endAnchor.parentNode) {\n                endAnchor.parentNode.removeChild(endAnchor);\n            }\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement()));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement()));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement()));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        let markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\n            `[cdkFocusRegion${bound}], ` +\n            `[cdk-focus-${bound}]`);\n        for (let i = 0; i < markers.length; i++) {\n            // @breaking-change 8.0.0\n            if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                    `attribute will be removed in 8.0.0.`, markers[i]);\n            }\n            else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0.`, markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement() {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` +\n            `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if (redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            if (!this._checker.isFocusable(redirectToElement)) {\n                const focusableChild = this._getFirstTabbableElement(redirectToElement);\n                focusableChild === null || focusableChild === void 0 ? void 0 : focusableChild.focus();\n                return !!focusableChild;\n            }\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement() {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement() {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        let children = root.children || root.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        let children = root.children || root.childNodes;\n        for (let i = children.length - 1; i >= 0; i--) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.pipe(Object(take[\"a\" /* take */])(1)).subscribe(fn);\n        }\n    }\n}\nlet a11y_FocusTrapFactory = /*@__PURE__*/ (() => {\n    class FocusTrapFactory {\n        constructor(_checker, _ngZone, _document) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._document = _document;\n        }\n        /**\n         * Creates a focus-trapped region around the given element.\n         * @param element The element around which focus will be trapped.\n         * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n         *     manually by the user.\n         * @returns The created focus trap instance.\n         */\n        create(element, deferCaptureElements = false) {\n            return new a11y_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n        }\n    }\n    FocusTrapFactory.ɵfac = function FocusTrapFactory_Factory(t) { return new (t || FocusTrapFactory)(core[\"bc\" /* ɵɵinject */](a11y_InteractivityChecker), core[\"bc\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"bc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */])); };\n    FocusTrapFactory.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(Object(core[\"bc\" /* ɵɵinject */])(a11y_InteractivityChecker), Object(core[\"bc\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"bc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */])); }, token: FocusTrapFactory, providedIn: \"root\" });\n    return FocusTrapFactory;\n})();\nlet a11y_CdkTrapFocus = /*@__PURE__*/ (() => {\n    class CdkTrapFocus {\n        constructor(_elementRef, _focusTrapFactory, _document) {\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n            this._previouslyFocusedElement = null;\n            this._document = _document;\n            this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n        }\n        /** Whether the focus trap is active. */\n        get enabled() { return this.focusTrap.enabled; }\n        set enabled(value) { this.focusTrap.enabled = coerceBooleanProperty(value); }\n        /**\n         * Whether the directive should automatically move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         */\n        get autoCapture() { return this._autoCapture; }\n        set autoCapture(value) { this._autoCapture = coerceBooleanProperty(value); }\n        ngOnDestroy() {\n            this.focusTrap.destroy();\n            // If we stored a previously focused element when using autoCapture, return focus to that\n            // element now that the trapped region is being destroyed.\n            if (this._previouslyFocusedElement) {\n                this._previouslyFocusedElement.focus();\n                this._previouslyFocusedElement = null;\n            }\n        }\n        ngAfterContentInit() {\n            this.focusTrap.attachAnchors();\n            if (this.autoCapture) {\n                this._captureFocus();\n            }\n        }\n        ngDoCheck() {\n            if (!this.focusTrap.hasAttached()) {\n                this.focusTrap.attachAnchors();\n            }\n        }\n        ngOnChanges(changes) {\n            const autoCaptureChange = changes['autoCapture'];\n            if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture &&\n                this.focusTrap.hasAttached()) {\n                this._captureFocus();\n            }\n        }\n        _captureFocus() {\n            this._previouslyFocusedElement = this._document.activeElement;\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    }\n    CdkTrapFocus.ɵfac = function CdkTrapFocus_Factory(t) { return new (t || CdkTrapFocus)(core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](a11y_FocusTrapFactory), core[\"Ob\" /* ɵɵdirectiveInject */](common[\"d\" /* DOCUMENT */])); };\n    CdkTrapFocus.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: CdkTrapFocus, selectors: [[\"\", \"cdkTrapFocus\", \"\"]], inputs: { enabled: [\"cdkTrapFocus\", \"enabled\"], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\"] }, exportAs: [\"cdkTrapFocus\"], features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkTrapFocus;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nclass ConfigurableFocusTrap extends a11y_FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {\n        super(_element, _checker, _ngZone, _document, config.defer);\n        this._focusTrapManager = _focusTrapManager;\n        this._inertStrategy = _inertStrategy;\n        this._focusTrapManager.register(this);\n    }\n    /** Whether the FocusTrap is enabled. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._enabled) {\n            this._focusTrapManager.register(this);\n        }\n        else {\n            this._focusTrapManager.deregister(this);\n        }\n    }\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy() {\n        this._focusTrapManager.deregister(this);\n        super.destroy();\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable() {\n        this._inertStrategy.preventFocus(this);\n        this.toggleAnchors(true);\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable() {\n        this._inertStrategy.allowFocus(this);\n        this.toggleAnchors(false);\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IE 11 compatible closest implementation that is able to start from non-Element Nodes. */\nfunction closest(element, selector) {\n    if (!(element instanceof Node)) {\n        return null;\n    }\n    let curr = element;\n    while (curr != null && !(curr instanceof Element)) {\n        curr = curr.parentNode;\n    }\n    return curr && (hasNativeClosest ?\n        curr.closest(selector) : polyfillClosest(curr, selector));\n}\n/** Polyfill for browsers without Element.closest. */\nfunction polyfillClosest(element, selector) {\n    let curr = element;\n    while (curr != null && !(curr instanceof Element && matches(curr, selector))) {\n        curr = curr.parentNode;\n    }\n    return (curr || null);\n}\nconst hasNativeClosest = typeof Element != 'undefined' && !!Element.prototype.closest;\n/** IE 11 compatible matches implementation. */\nfunction matches(element, selector) {\n    return element.matches ?\n        element.matches(selector) :\n        element['msMatchesSelector'](selector);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nclass EventListenerFocusTrapInertStrategy {\n    constructor() {\n        /** Focus event handler. */\n        this._listener = null;\n    }\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap) {\n        // Ensure there's only one listener per document\n        if (this._listener) {\n            focusTrap._document.removeEventListener('focus', this._listener, true);\n        }\n        this._listener = (e) => this._trapFocus(focusTrap, e);\n        focusTrap._ngZone.runOutsideAngular(() => {\n            focusTrap._document.addEventListener('focus', this._listener, true);\n        });\n    }\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap) {\n        if (!this._listener) {\n            return;\n        }\n        focusTrap._document.removeEventListener('focus', this._listener, true);\n        this._listener = null;\n    }\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    _trapFocus(focusTrap, event) {\n        const target = event.target;\n        const focusTrapRoot = focusTrap._element;\n        // Don't refocus if target was in an overlay, because the overlay might be associated\n        // with an element inside the FocusTrap, ex. mat-select.\n        if (!focusTrapRoot.contains(target) && closest(target, 'div.cdk-overlay-pane') === null) {\n            // Some legacy FocusTrap usages have logic that focuses some element on the page\n            // just before FocusTrap is destroyed. For backwards compatibility, wait\n            // to be sure FocusTrap is still enabled before refocusing.\n            setTimeout(() => {\n                // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n                if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n                    focusTrap.focusFirstTabbableElement();\n                }\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for creating a ConfigurableFocusTrap.\n */\nclass ConfigurableFocusTrapConfig {\n    constructor() {\n        /**\n         * Whether to defer the creation of FocusTrap elements to be\n         * done manually by the user. Default is to create them\n         * automatically.\n         */\n        this.defer = false;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the inert strategy. */\nconst FOCUS_TRAP_INERT_STRATEGY = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('FOCUS_TRAP_INERT_STRATEGY');\nlet a11y_FocusTrapManager = /*@__PURE__*/ (() => {\n    class FocusTrapManager {\n        constructor() {\n            // A stack of the FocusTraps on the page. Only the FocusTrap at the\n            // top of the stack is active.\n            this._focusTrapStack = [];\n        }\n        /**\n         * Disables the FocusTrap at the top of the stack, and then pushes\n         * the new FocusTrap onto the stack.\n         */\n        register(focusTrap) {\n            // Dedupe focusTraps that register multiple times.\n            this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);\n            let stack = this._focusTrapStack;\n            if (stack.length) {\n                stack[stack.length - 1]._disable();\n            }\n            stack.push(focusTrap);\n            focusTrap._enable();\n        }\n        /**\n         * Removes the FocusTrap from the stack, and activates the\n         * FocusTrap that is the new top of the stack.\n         */\n        deregister(focusTrap) {\n            focusTrap._disable();\n            const stack = this._focusTrapStack;\n            const i = stack.indexOf(focusTrap);\n            if (i !== -1) {\n                stack.splice(i, 1);\n                if (stack.length) {\n                    stack[stack.length - 1]._enable();\n                }\n            }\n        }\n    }\n    FocusTrapManager.ɵfac = function FocusTrapManager_Factory(t) { return new (t || FocusTrapManager)(); };\n    FocusTrapManager.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function FocusTrapManager_Factory() { return new FocusTrapManager(); }, token: FocusTrapManager, providedIn: \"root\" });\n    return FocusTrapManager;\n})();\nlet a11y_ConfigurableFocusTrapFactory = /*@__PURE__*/ (() => {\n    class ConfigurableFocusTrapFactory {\n        constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._focusTrapManager = _focusTrapManager;\n            this._document = _document;\n            // TODO split up the strategies into different modules, similar to DateAdapter.\n            this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();\n        }\n        create(element, config = new ConfigurableFocusTrapConfig()) {\n            let configObject;\n            if (typeof config === 'boolean') {\n                configObject = new ConfigurableFocusTrapConfig();\n                configObject.defer = config;\n            }\n            else {\n                configObject = config;\n            }\n            return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);\n        }\n    }\n    ConfigurableFocusTrapFactory.ɵfac = function ConfigurableFocusTrapFactory_Factory(t) { return new (t || ConfigurableFocusTrapFactory)(core[\"bc\" /* ɵɵinject */](a11y_InteractivityChecker), core[\"bc\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"bc\" /* ɵɵinject */](a11y_FocusTrapManager), core[\"bc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */]), core[\"bc\" /* ɵɵinject */](FOCUS_TRAP_INERT_STRATEGY, 8)); };\n    ConfigurableFocusTrapFactory.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function ConfigurableFocusTrapFactory_Factory() { return new ConfigurableFocusTrapFactory(Object(core[\"bc\" /* ɵɵinject */])(a11y_InteractivityChecker), Object(core[\"bc\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"bc\" /* ɵɵinject */])(a11y_FocusTrapManager), Object(core[\"bc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */]), Object(core[\"bc\" /* ɵɵinject */])(FOCUS_TRAP_INERT_STRATEGY, 8)); }, token: ConfigurableFocusTrapFactory, providedIn: \"root\" });\n    return ConfigurableFocusTrapFactory;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/** @docs-private */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\nlet a11y_LiveAnnouncer = /*@__PURE__*/ (() => {\n    class LiveAnnouncer {\n        constructor(elementToken, _ngZone, _document, _defaultOptions) {\n            this._ngZone = _ngZone;\n            this._defaultOptions = _defaultOptions;\n            // We inject the live element and document as `any` because the constructor signature cannot\n            // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n            // a class decorator causes TypeScript to preserve the constructor signature types.\n            this._document = _document;\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n        announce(message, ...args) {\n            const defaultOptions = this._defaultOptions;\n            let politeness;\n            let duration;\n            if (args.length === 1 && typeof args[0] === 'number') {\n                duration = args[0];\n            }\n            else {\n                [politeness, duration] = args;\n            }\n            this.clear();\n            clearTimeout(this._previousTimeout);\n            if (!politeness) {\n                politeness =\n                    (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\n            }\n            if (duration == null && defaultOptions) {\n                duration = defaultOptions.duration;\n            }\n            // TODO: ensure changing the politeness works on all environments we support.\n            this._liveElement.setAttribute('aria-live', politeness);\n            // This 100ms timeout is necessary for some browser + screen-reader combinations:\n            // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n            // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n            //   second time without clearing and then using a non-zero delay.\n            // (using JAWS 17 at time of this writing).\n            return this._ngZone.runOutsideAngular(() => {\n                return new Promise(resolve => {\n                    clearTimeout(this._previousTimeout);\n                    this._previousTimeout = setTimeout(() => {\n                        this._liveElement.textContent = message;\n                        resolve();\n                        if (typeof duration === 'number') {\n                            this._previousTimeout = setTimeout(() => this.clear(), duration);\n                        }\n                    }, 100);\n                });\n            });\n        }\n        /**\n         * Clears the current text from the announcer element. Can be used to prevent\n         * screen readers from reading the text out again while the user is going\n         * through the page landmarks.\n         */\n        clear() {\n            if (this._liveElement) {\n                this._liveElement.textContent = '';\n            }\n        }\n        ngOnDestroy() {\n            clearTimeout(this._previousTimeout);\n            if (this._liveElement && this._liveElement.parentNode) {\n                this._liveElement.parentNode.removeChild(this._liveElement);\n                this._liveElement = null;\n            }\n        }\n        _createLiveElement() {\n            const elementClass = 'cdk-live-announcer-element';\n            const previousElements = this._document.getElementsByClassName(elementClass);\n            const liveEl = this._document.createElement('div');\n            // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n            for (let i = 0; i < previousElements.length; i++) {\n                previousElements[i].parentNode.removeChild(previousElements[i]);\n            }\n            liveEl.classList.add(elementClass);\n            liveEl.classList.add('cdk-visually-hidden');\n            liveEl.setAttribute('aria-atomic', 'true');\n            liveEl.setAttribute('aria-live', 'polite');\n            this._document.body.appendChild(liveEl);\n            return liveEl;\n        }\n    }\n    LiveAnnouncer.ɵfac = function LiveAnnouncer_Factory(t) { return new (t || LiveAnnouncer)(core[\"bc\" /* ɵɵinject */](LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), core[\"bc\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"bc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */]), core[\"bc\" /* ɵɵinject */](LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); };\n    LiveAnnouncer.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(Object(core[\"bc\" /* ɵɵinject */])(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), Object(core[\"bc\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"bc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */]), Object(core[\"bc\" /* ɵɵinject */])(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\n    return LiveAnnouncer;\n})();\nlet a11y_CdkAriaLive = /*@__PURE__*/ (() => {\n    class CdkAriaLive {\n        constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n            this._elementRef = _elementRef;\n            this._liveAnnouncer = _liveAnnouncer;\n            this._contentObserver = _contentObserver;\n            this._ngZone = _ngZone;\n            this._politeness = 'polite';\n        }\n        /** The aria-live politeness level to use when announcing messages. */\n        get politeness() { return this._politeness; }\n        set politeness(value) {\n            this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n            if (this._politeness === 'off') {\n                if (this._subscription) {\n                    this._subscription.unsubscribe();\n                    this._subscription = null;\n                }\n            }\n            else if (!this._subscription) {\n                this._subscription = this._ngZone.runOutsideAngular(() => {\n                    return this._contentObserver\n                        .observe(this._elementRef)\n                        .subscribe(() => {\n                        // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                        const elementText = this._elementRef.nativeElement.textContent;\n                        // The `MutationObserver` fires also for attribute\n                        // changes which we don't want to announce.\n                        if (elementText !== this._previousAnnouncedText) {\n                            this._liveAnnouncer.announce(elementText, this._politeness);\n                            this._previousAnnouncedText = elementText;\n                        }\n                    });\n                });\n            }\n        }\n        ngOnDestroy() {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n            }\n        }\n    }\n    CdkAriaLive.ɵfac = function CdkAriaLive_Factory(t) { return new (t || CdkAriaLive)(core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](a11y_LiveAnnouncer), core[\"Ob\" /* ɵɵdirectiveInject */](observers_ContentObserver), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    CdkAriaLive.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: CdkAriaLive, selectors: [[\"\", \"cdkAriaLive\", \"\"]], inputs: { politeness: [\"cdkAriaLive\", \"politeness\"] }, exportAs: [\"cdkAriaLive\"] });\n    return CdkAriaLive;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nfunction isFakeMousedownFromScreenReader(event) {\n    // We can typically distinguish between these faked mousedown events and real mousedown events\n    // using the \"buttons\" property. While real mousedowns will indicate the mouse button that was\n    // pressed (e.g. \"1\" for the left mouse button), faked mousedowns will usually set the property\n    // value to 0.\n    return event.buttons === 0;\n}\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nfunction isFakeTouchstartFromScreenReader(event) {\n    const touch = (event.touches && event.touches[0]) ||\n        (event.changedTouches && event.changedTouches[0]);\n    // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n    // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n    // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n    // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n    return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) &&\n        (touch.radiusY == null || touch.radiusY === 1);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nconst TOUCH_BUFFER_MS = 650;\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = /*@__PURE__*/ normalizePassiveListenerOptions({\n    passive: true,\n    capture: true\n});\nlet a11y_FocusMonitor = /*@__PURE__*/ (() => {\n    class FocusMonitor {\n        constructor(_ngZone, _platform, \n        /** @breaking-change 11.0.0 make document required */\n        document, options) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** The focus origin that the next focus event is a result of. */\n            this._origin = null;\n            /** Whether the window has just been focused. */\n            this._windowFocused = false;\n            /** Map of elements being monitored to their info. */\n            this._elementInfo = new Map();\n            /** The number of elements currently being monitored. */\n            this._monitoredElementCount = 0;\n            /**\n             * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n             * as well as the number of monitored elements that they contain. We have to treat focus/blur\n             * handlers differently from the rest of the events, because the browser won't emit events\n             * to the document when focus moves inside of a shadow root.\n             */\n            this._rootNodeFocusListenerCount = new Map();\n            /**\n             * Event listener for `keydown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentKeydownListener = () => {\n                // On keydown record the origin and clear any touch event that may be in progress.\n                this._lastTouchTarget = null;\n                this._setOriginForCurrentEventQueue('keyboard');\n            };\n            /**\n             * Event listener for `mousedown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentMousedownListener = (event) => {\n                // On mousedown record the origin only if there is not touch\n                // target, since a mousedown can happen as a result of a touch event.\n                if (!this._lastTouchTarget) {\n                    // In some cases screen readers fire fake `mousedown` events instead of `keydown`.\n                    // Resolve the focus source to `keyboard` if we detect one of them.\n                    const source = isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse';\n                    this._setOriginForCurrentEventQueue(source);\n                }\n            };\n            /**\n             * Event listener for `touchstart` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentTouchstartListener = (event) => {\n                // Some screen readers will fire a fake `touchstart` event if an element is activated using\n                // the keyboard while on a device with a touchsreen. Consider such events as keyboard focus.\n                if (!isFakeTouchstartFromScreenReader(event)) {\n                    // When the touchstart event fires the focus event is not yet in the event queue. This means\n                    // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n                    // see if a focus happens.\n                    if (this._touchTimeoutId != null) {\n                        clearTimeout(this._touchTimeoutId);\n                    }\n                    this._lastTouchTarget = getTarget(event);\n                    this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n                }\n                else if (!this._lastTouchTarget) {\n                    this._setOriginForCurrentEventQueue('keyboard');\n                }\n            };\n            /**\n             * Event listener for `focus` events on the window.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._windowFocusListener = () => {\n                // Make a note of when the window regains focus, so we can\n                // restore the origin info for the focused element.\n                this._windowFocused = true;\n                this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\n            };\n            /**\n             * Event listener for `focus` and 'blur' events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._rootNodeFocusAndBlurListener = (event) => {\n                const target = getTarget(event);\n                const handler = event.type === 'focus' ? this._onFocus : this._onBlur;\n                // We need to walk up the ancestor chain in order to support `checkChildren`.\n                for (let element = target; element; element = element.parentElement) {\n                    handler.call(this, event, element);\n                }\n            };\n            this._document = document;\n            this._detectionMode = (options === null || options === void 0 ? void 0 : options.detectionMode) || 0 /* IMMEDIATE */;\n        }\n        monitor(element, checkChildren = false) {\n            const nativeElement = coerceElement(element);\n            // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n            if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n                return Object(of[\"a\" /* of */])(null);\n            }\n            // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n            // the shadow root, rather than the `document`, because the browser won't emit focus events\n            // to the `document`, if focus is moving within the same shadow root.\n            const rootNode = _getShadowRoot(nativeElement) || this._getDocument();\n            const cachedInfo = this._elementInfo.get(nativeElement);\n            // Check if we're already monitoring this element.\n            if (cachedInfo) {\n                if (checkChildren) {\n                    // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                    // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                    // robust solution.\n                    cachedInfo.checkChildren = true;\n                }\n                return cachedInfo.subject;\n            }\n            // Create monitored element info.\n            const info = {\n                checkChildren: checkChildren,\n                subject: new Subject[\"a\" /* Subject */](),\n                rootNode\n            };\n            this._elementInfo.set(nativeElement, info);\n            this._registerGlobalListeners(info);\n            return info.subject;\n        }\n        stopMonitoring(element) {\n            const nativeElement = coerceElement(element);\n            const elementInfo = this._elementInfo.get(nativeElement);\n            if (elementInfo) {\n                elementInfo.subject.complete();\n                this._setClasses(nativeElement);\n                this._elementInfo.delete(nativeElement);\n                this._removeGlobalListeners(elementInfo);\n            }\n        }\n        focusVia(element, origin, options) {\n            const nativeElement = coerceElement(element);\n            const focusedElement = this._getDocument().activeElement;\n            // If the element is focused already, calling `focus` again won't trigger the event listener\n            // which means that the focus classes won't be updated. If that's the case, update the classes\n            // directly without waiting for an event.\n            if (nativeElement === focusedElement) {\n                this._getClosestElementsInfo(nativeElement)\n                    .forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n            }\n            else {\n                this._setOriginForCurrentEventQueue(origin);\n                // `focus` isn't available on the server\n                if (typeof nativeElement.focus === 'function') {\n                    nativeElement.focus(options);\n                }\n            }\n        }\n        ngOnDestroy() {\n            this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n        }\n        /** Access injected document if available or fallback to global document reference */\n        _getDocument() {\n            return this._document || document;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            const doc = this._getDocument();\n            return doc.defaultView || window;\n        }\n        _toggleClass(element, className, shouldSet) {\n            if (shouldSet) {\n                element.classList.add(className);\n            }\n            else {\n                element.classList.remove(className);\n            }\n        }\n        _getFocusOrigin(event) {\n            // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n            // 1) The window has just regained focus, in which case we want to restore the focused state of\n            //    the element from before the window blurred.\n            // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n            // 3) The element was programmatically focused, in which case we should mark the origin as\n            //    'program'.\n            if (this._origin) {\n                return this._origin;\n            }\n            if (this._windowFocused && this._lastFocusOrigin) {\n                return this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                return 'touch';\n            }\n            else {\n                return 'program';\n            }\n        }\n        /**\n         * Sets the focus classes on the element based on the given focus origin.\n         * @param element The element to update the classes on.\n         * @param origin The focus origin.\n         */\n        _setClasses(element, origin) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n        /**\n         * Sets the origin and schedules an async function to clear it at the end of the event queue.\n         * If the detection mode is 'eventual', the origin is never cleared.\n         * @param origin The origin to set.\n         */\n        _setOriginForCurrentEventQueue(origin) {\n            this._ngZone.runOutsideAngular(() => {\n                this._origin = origin;\n                if (this._detectionMode === 0 /* IMMEDIATE */) {\n                    // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n                    // tick after the interaction event fired. To ensure the focus origin is always correct,\n                    // the focus origin will be determined at the beginning of the next tick.\n                    this._originTimeoutId = setTimeout(() => this._origin = null, 1);\n                }\n            });\n        }\n        /**\n         * Checks whether the given focus event was caused by a touchstart event.\n         * @param event The focus event to check.\n         * @returns Whether the event was caused by a touch.\n         */\n        _wasCausedByTouch(event) {\n            // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n            // Consider the following dom structure:\n            //\n            // <div #parent tabindex=\"0\" cdkFocusClasses>\n            //   <div #child (click)=\"#parent.focus()\"></div>\n            // </div>\n            //\n            // If the user touches the #child element and the #parent is programmatically focused as a\n            // result, this code will still consider it to have been caused by the touch event and will\n            // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n            // relatively small edge-case that can be worked around by using\n            // focusVia(parentEl, 'program') to focus the parent element.\n            //\n            // If we decide that we absolutely must handle this case correctly, we can do so by listening\n            // for the first focus event after the touchstart, and then the first blur event after that\n            // focus event. When that blur event fires we know that whatever follows is not a result of the\n            // touchstart.\n            const focusTarget = getTarget(event);\n            return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n                (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n        }\n        /**\n         * Handles focus events on a registered element.\n         * @param event The focus event.\n         * @param element The monitored element.\n         */\n        _onFocus(event, element) {\n            // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n            // focus event affecting the monitored element. If we want to use the origin of the first event\n            // instead we should check for the cdk-focused class here and return if the element already has\n            // it. (This only matters for elements that have includesChildren = true).\n            // If we are not counting child-element-focus as focused, make sure that the event target is the\n            // monitored element itself.\n            const elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (!elementInfo.checkChildren && element !== getTarget(event))) {\n                return;\n            }\n            this._originChanged(element, this._getFocusOrigin(event), elementInfo);\n        }\n        /**\n         * Handles blur events on a registered element.\n         * @param event The blur event.\n         * @param element The monitored element.\n         */\n        _onBlur(event, element) {\n            // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n            // order to focus another child of the monitored element.\n            const elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n                return;\n            }\n            this._setClasses(element);\n            this._emitOrigin(elementInfo.subject, null);\n        }\n        _emitOrigin(subject, origin) {\n            this._ngZone.run(() => subject.next(origin));\n        }\n        _registerGlobalListeners(elementInfo) {\n            if (!this._platform.isBrowser) {\n                return;\n            }\n            const rootNode = elementInfo.rootNode;\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n            if (!rootNodeFocusListeners) {\n                this._ngZone.runOutsideAngular(() => {\n                    rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                });\n            }\n            this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n            // Register global listeners when first element is monitored.\n            if (++this._monitoredElementCount === 1) {\n                // Note: we listen to events in the capture phase so we\n                // can detect them even if the user stops propagation.\n                this._ngZone.runOutsideAngular(() => {\n                    const document = this._getDocument();\n                    const window = this._getWindow();\n                    document.addEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                    document.addEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                    document.addEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                    window.addEventListener('focus', this._windowFocusListener);\n                });\n            }\n        }\n        _removeGlobalListeners(elementInfo) {\n            const rootNode = elementInfo.rootNode;\n            if (this._rootNodeFocusListenerCount.has(rootNode)) {\n                const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n                if (rootNodeFocusListeners > 1) {\n                    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n                }\n                else {\n                    rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    this._rootNodeFocusListenerCount.delete(rootNode);\n                }\n            }\n            // Unregister global listeners when last element is unmonitored.\n            if (!--this._monitoredElementCount) {\n                const document = this._getDocument();\n                const window = this._getWindow();\n                document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                window.removeEventListener('focus', this._windowFocusListener);\n                // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n                clearTimeout(this._windowFocusTimeoutId);\n                clearTimeout(this._touchTimeoutId);\n                clearTimeout(this._originTimeoutId);\n            }\n        }\n        /** Updates all the state on an element once its focus origin has changed. */\n        _originChanged(element, origin, elementInfo) {\n            this._setClasses(element, origin);\n            this._emitOrigin(elementInfo.subject, origin);\n            this._lastFocusOrigin = origin;\n        }\n        /**\n         * Collects the `MonitoredElementInfo` of a particular element and\n         * all of its ancestors that have enabled `checkChildren`.\n         * @param element Element from which to start the search.\n         */\n        _getClosestElementsInfo(element) {\n            const results = [];\n            this._elementInfo.forEach((info, currentElement) => {\n                if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                    results.push([currentElement, info]);\n                }\n            });\n            return results;\n        }\n    }\n    FocusMonitor.ɵfac = function FocusMonitor_Factory(t) { return new (t || FocusMonitor)(core[\"bc\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"bc\" /* ɵɵinject */](platform_Platform), core[\"bc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */], 8), core[\"bc\" /* ɵɵinject */](FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); };\n    FocusMonitor.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function FocusMonitor_Factory() { return new FocusMonitor(Object(core[\"bc\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"bc\" /* ɵɵinject */])(platform_Platform), Object(core[\"bc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */], 8), Object(core[\"bc\" /* ɵɵinject */])(FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); }, token: FocusMonitor, providedIn: \"root\" });\n    return FocusMonitor;\n})();\n/** Gets the target of an event, accounting for Shadow DOM. */\nfunction getTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\nlet a11y_CdkMonitorFocus = /*@__PURE__*/ (() => {\n    class CdkMonitorFocus {\n        constructor(_elementRef, _focusMonitor) {\n            this._elementRef = _elementRef;\n            this._focusMonitor = _focusMonitor;\n            this.cdkFocusChange = new core[\"n\" /* EventEmitter */]();\n        }\n        ngAfterViewInit() {\n            const element = this._elementRef.nativeElement;\n            this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n                .subscribe(origin => this.cdkFocusChange.emit(origin));\n        }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n            if (this._monitorSubscription) {\n                this._monitorSubscription.unsubscribe();\n            }\n        }\n    }\n    CdkMonitorFocus.ɵfac = function CdkMonitorFocus_Factory(t) { return new (t || CdkMonitorFocus)(core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](a11y_FocusMonitor)); };\n    CdkMonitorFocus.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: CdkMonitorFocus, selectors: [[\"\", \"cdkMonitorElementFocus\", \"\"], [\"\", \"cdkMonitorSubtreeFocus\", \"\"]], outputs: { cdkFocusChange: \"cdkFocusChange\" } });\n    return CdkMonitorFocus;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\nlet a11y_HighContrastModeDetector = /*@__PURE__*/ (() => {\n    class HighContrastModeDetector {\n        constructor(_platform, document) {\n            this._platform = _platform;\n            this._document = document;\n        }\n        /** Gets the current high-contrast-mode for the page. */\n        getHighContrastMode() {\n            if (!this._platform.isBrowser) {\n                return 0 /* NONE */;\n            }\n            // Create a test element with an arbitrary background-color that is neither black nor\n            // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n            // appending the test element to the DOM does not affect layout by absolutely positioning it\n            const testElement = this._document.createElement('div');\n            testElement.style.backgroundColor = 'rgb(1,2,3)';\n            testElement.style.position = 'absolute';\n            this._document.body.appendChild(testElement);\n            // Get the computed style for the background color, collapsing spaces to normalize between\n            // browsers. Once we get this color, we no longer need the test element. Access the `window`\n            // via the document so we can fake it in tests. Note that we have extra null checks, because\n            // this logic will likely run during app bootstrap and throwing can break the entire app.\n            const documentWindow = this._document.defaultView || window;\n            const computedStyle = (documentWindow && documentWindow.getComputedStyle) ?\n                documentWindow.getComputedStyle(testElement) : null;\n            const computedColor = (computedStyle && computedStyle.backgroundColor || '').replace(/ /g, '');\n            this._document.body.removeChild(testElement);\n            switch (computedColor) {\n                case 'rgb(0,0,0)': return 2 /* WHITE_ON_BLACK */;\n                case 'rgb(255,255,255)': return 1 /* BLACK_ON_WHITE */;\n            }\n            return 0 /* NONE */;\n        }\n        /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n        _applyBodyHighContrastModeCssClasses() {\n            if (this._platform.isBrowser && this._document.body) {\n                const bodyClasses = this._document.body.classList;\n                // IE11 doesn't support `classList` operations with multiple arguments\n                bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                bodyClasses.remove(BLACK_ON_WHITE_CSS_CLASS);\n                bodyClasses.remove(WHITE_ON_BLACK_CSS_CLASS);\n                const mode = this.getHighContrastMode();\n                if (mode === 1 /* BLACK_ON_WHITE */) {\n                    bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                    bodyClasses.add(BLACK_ON_WHITE_CSS_CLASS);\n                }\n                else if (mode === 2 /* WHITE_ON_BLACK */) {\n                    bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                    bodyClasses.add(WHITE_ON_BLACK_CSS_CLASS);\n                }\n            }\n        }\n    }\n    HighContrastModeDetector.ɵfac = function HighContrastModeDetector_Factory(t) { return new (t || HighContrastModeDetector)(core[\"bc\" /* ɵɵinject */](platform_Platform), core[\"bc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */])); };\n    HighContrastModeDetector.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function HighContrastModeDetector_Factory() { return new HighContrastModeDetector(Object(core[\"bc\" /* ɵɵinject */])(platform_Platform), Object(core[\"bc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */])); }, token: HighContrastModeDetector, providedIn: \"root\" });\n    return HighContrastModeDetector;\n})();\nlet a11y_A11yModule = /*@__PURE__*/ (() => {\n    class A11yModule {\n        constructor(highContrastModeDetector) {\n            highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n        }\n    }\n    A11yModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: A11yModule });\n    A11yModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function A11yModule_Factory(t) { return new (t || A11yModule)(core[\"bc\" /* ɵɵinject */](a11y_HighContrastModeDetector)); }, imports: [[platform_PlatformModule, observers_ObserversModule]] });\n    return A11yModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](a11y_A11yModule, { declarations: function () { return [a11y_CdkAriaLive, a11y_CdkTrapFocus, a11y_CdkMonitorFocus]; }, imports: function () { return [platform_PlatformModule, observers_ObserversModule]; }, exports: function () { return [a11y_CdkAriaLive, a11y_CdkTrapFocus, a11y_CdkMonitorFocus]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=a11y.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\n\nconst DIR_DOCUMENT = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/** @docs-private */\nfunction DIR_DOCUMENT_FACTORY() {\n    return Object(core[\"W\" /* inject */])(common[\"d\" /* DOCUMENT */]);\n}\nlet bidi_Directionality = /*@__PURE__*/ (() => {\n    class Directionality {\n        constructor(_document) {\n            /** The current 'ltr' or 'rtl' value. */\n            this.value = 'ltr';\n            /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n            this.change = new core[\"n\" /* EventEmitter */]();\n            if (_document) {\n                // TODO: handle 'auto' value -\n                // We still need to account for dir=\"auto\".\n                // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n                // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n                const bodyDir = _document.body ? _document.body.dir : null;\n                const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n                const value = bodyDir || htmlDir;\n                this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\n            }\n        }\n        ngOnDestroy() {\n            this.change.complete();\n        }\n    }\n    Directionality.ɵfac = function Directionality_Factory(t) { return new (t || Directionality)(core[\"bc\" /* ɵɵinject */](DIR_DOCUMENT, 8)); };\n    Directionality.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function Directionality_Factory() { return new Directionality(Object(core[\"bc\" /* ɵɵinject */])(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\n    return Directionality;\n})();\nlet bidi_Dir = /*@__PURE__*/ (() => {\n    class Dir {\n        constructor() {\n            /** Normalized direction that accounts for invalid/unsupported values. */\n            this._dir = 'ltr';\n            /** Whether the `value` has been set to its initial value. */\n            this._isInitialized = false;\n            /** Event emitted when the direction changes. */\n            this.change = new core[\"n\" /* EventEmitter */]();\n        }\n        /** @docs-private */\n        get dir() { return this._dir; }\n        set dir(value) {\n            const old = this._dir;\n            const normalizedValue = value ? value.toLowerCase() : value;\n            this._rawDir = value;\n            this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        }\n        /** Current layout direction of the element. */\n        get value() { return this.dir; }\n        /** Initialize once default value has been set. */\n        ngAfterContentInit() {\n            this._isInitialized = true;\n        }\n        ngOnDestroy() {\n            this.change.complete();\n        }\n    }\n    Dir.ɵfac = function Dir_Factory(t) { return new (t || Dir)(); };\n    Dir.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: Dir, selectors: [[\"\", \"dir\", \"\"]], hostVars: 1, hostBindings: function Dir_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Db\" /* ɵɵattribute */](\"dir\", ctx._rawDir);\n            }\n        }, inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, exportAs: [\"dir\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: bidi_Directionality, useExisting: Dir }])] });\n    return Dir;\n})();\nlet bidi_BidiModule = /*@__PURE__*/ (() => {\n    class BidiModule {\n    }\n    BidiModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: BidiModule });\n    BidiModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function BidiModule_Factory(t) { return new (t || BidiModule)(); } });\n    return BidiModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](bidi_BidiModule, { declarations: [bidi_Dir], exports: [bidi_Dir] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=bidi.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/fesm2015/cdk.js\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Current version of the Angular Component Development Kit. */\nconst VERSION = /*@__PURE__*/ new core[\"Q\" /* Version */]('11.2.10');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//# sourceMappingURL=cdk.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js + 1 modules\nvar animations = __webpack_require__(\"R1ws\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/core.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Current version of Angular Material. */\n\n\n\n\nconst _c0 = [\"*\", [[\"mat-option\"], [\"ng-container\"]]];\nconst _c1 = [\"*\", \"mat-option, ng-container\"];\nfunction MatOption_mat_pseudo_checkbox_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Pb\" /* ɵɵelement */](0, \"mat-pseudo-checkbox\", 4);\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"ic\" /* ɵɵnextContext */]();\n        core[\"oc\" /* ɵɵproperty */](\"state\", ctx_r0.selected ? \"checked\" : \"unchecked\")(\"disabled\", ctx_r0.disabled);\n    }\n}\nfunction MatOption_span_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Ub\" /* ɵɵelementStart */](0, \"span\", 5);\n        core[\"Hc\" /* ɵɵtext */](1);\n        core[\"Tb\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"ic\" /* ɵɵnextContext */]();\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Jc\" /* ɵɵtextInterpolate1 */](\"(\", ctx_r1.group.label, \")\");\n    }\n}\nconst _c2 = [\"*\"];\nconst core_VERSION = /*@__PURE__*/ new core[\"Q\" /* Version */]('11.2.10');\nlet AnimationCurves = /*@__PURE__*/ (() => {\n    class AnimationCurves {\n    }\n    AnimationCurves.STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';\n    AnimationCurves.DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';\n    AnimationCurves.ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';\n    AnimationCurves.SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';\n    return AnimationCurves;\n})();\nlet AnimationDurations = /*@__PURE__*/ (() => {\n    class AnimationDurations {\n    }\n    AnimationDurations.COMPLEX = '375ms';\n    AnimationDurations.ENTERING = '225ms';\n    AnimationDurations.EXITING = '195ms';\n    return AnimationDurations;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Private version constant to circumvent test/build issues,\n// i.e. avoid core to depend on the @angular/material primary entry-point\n// Can be removed once the Material primary entry-point no longer\n// re-exports all secondary entry-points\nconst VERSION$1 = /*@__PURE__*/ new core[\"Q\" /* Version */]('11.2.10');\n/** @docs-private */\nfunction MATERIAL_SANITY_CHECKS_FACTORY() {\n    return true;\n}\n/** Injection token that configures whether the Material sanity checks are enabled. */\nconst MATERIAL_SANITY_CHECKS = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('mat-sanity-checks', {\n    providedIn: 'root',\n    factory: MATERIAL_SANITY_CHECKS_FACTORY,\n});\nlet core_MatCommonModule = /*@__PURE__*/ (() => {\n    class MatCommonModule {\n        constructor(highContrastModeDetector, sanityChecks, document) {\n            /** Whether we've done the global sanity checks (e.g. a theme is loaded, there is a doctype). */\n            this._hasDoneGlobalChecks = false;\n            this._document = document;\n            // While A11yModule also does this, we repeat it here to avoid importing A11yModule\n            // in MatCommonModule.\n            highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n            // Note that `_sanityChecks` is typed to `any`, because AoT\n            // throws an error if we use the `SanityChecks` type directly.\n            this._sanityChecks = sanityChecks;\n            if (!this._hasDoneGlobalChecks) {\n                this._checkDoctypeIsDefined();\n                this._checkThemeIsPresent();\n                this._checkCdkVersionMatch();\n                this._hasDoneGlobalChecks = true;\n            }\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            const win = this._document.defaultView || window;\n            return typeof win === 'object' && win ? win : null;\n        }\n        /** Whether any sanity checks are enabled. */\n        _checksAreEnabled() {\n            // TODO(crisbeto): we can't use `ngDevMode` here yet, because ViewEngine apps might not support\n            // it. Since these checks can have performance implications and they aren't tree shakeable\n            // in their current form, we can leave the `isDevMode` check in for now.\n            // tslint:disable-next-line:ban\n            return Object(core[\"X\" /* isDevMode */])() && !this._isTestEnv();\n        }\n        /** Whether the code is running in tests. */\n        _isTestEnv() {\n            const window = this._getWindow();\n            return window && (window.__karma__ || window.jasmine);\n        }\n        _checkDoctypeIsDefined() {\n            const isEnabled = this._checksAreEnabled() &&\n                (this._sanityChecks === true || this._sanityChecks.doctype);\n            if (isEnabled && !this._document.doctype) {\n                console.warn('Current document does not have a doctype. This may cause ' +\n                    'some Angular Material components not to behave as expected.');\n            }\n        }\n        _checkThemeIsPresent() {\n            // We need to assert that the `body` is defined, because these checks run very early\n            // and the `body` won't be defined if the consumer put their scripts in the `head`.\n            const isDisabled = !this._checksAreEnabled() ||\n                (this._sanityChecks === false || !this._sanityChecks.theme);\n            if (isDisabled || !this._document.body || typeof getComputedStyle !== 'function') {\n                return;\n            }\n            const testElement = this._document.createElement('div');\n            testElement.classList.add('mat-theme-loaded-marker');\n            this._document.body.appendChild(testElement);\n            const computedStyle = getComputedStyle(testElement);\n            // In some situations the computed style of the test element can be null. For example in\n            // Firefox, the computed style is null if an application is running inside of a hidden iframe.\n            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n            if (computedStyle && computedStyle.display !== 'none') {\n                console.warn('Could not find Angular Material core theme. Most Material ' +\n                    'components may not work as expected. For more info refer ' +\n                    'to the theming guide: https://material.angular.io/guide/theming');\n            }\n            this._document.body.removeChild(testElement);\n        }\n        /** Checks whether the material version matches the cdk version */\n        _checkCdkVersionMatch() {\n            const isEnabled = this._checksAreEnabled() &&\n                (this._sanityChecks === true || this._sanityChecks.version);\n            if (isEnabled && VERSION$1.full !== VERSION.full) {\n                console.warn('The Angular Material version (' + VERSION$1.full + ') does not match ' +\n                    'the Angular CDK version (' + VERSION.full + ').\\n' +\n                    'Please ensure the versions of these two packages exactly match.');\n            }\n        }\n    }\n    MatCommonModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: MatCommonModule });\n    MatCommonModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function MatCommonModule_Factory(t) { return new (t || MatCommonModule)(core[\"bc\" /* ɵɵinject */](a11y_HighContrastModeDetector), core[\"bc\" /* ɵɵinject */](MATERIAL_SANITY_CHECKS, 8), core[\"bc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */])); }, imports: [[bidi_BidiModule], bidi_BidiModule] });\n    return MatCommonModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](core_MatCommonModule, { imports: function () { return [bidi_BidiModule]; }, exports: function () { return [bidi_BidiModule]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `disabled` property. */\nfunction mixinDisabled(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            this._disabled = false;\n        }\n        get disabled() { return this._disabled; }\n        set disabled(value) { this._disabled = coerceBooleanProperty(value); }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `color` property. */\nfunction mixinColor(base, defaultColor) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            this.defaultColor = defaultColor;\n            // Set the default color that can be specified from the mixin.\n            this.color = defaultColor;\n        }\n        get color() { return this._color; }\n        set color(value) {\n            const colorPalette = value || this.defaultColor;\n            if (colorPalette !== this._color) {\n                if (this._color) {\n                    this._elementRef.nativeElement.classList.remove(`mat-${this._color}`);\n                }\n                if (colorPalette) {\n                    this._elementRef.nativeElement.classList.add(`mat-${colorPalette}`);\n                }\n                this._color = colorPalette;\n            }\n        }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `disableRipple` property. */\nfunction mixinDisableRipple(base) {\n    class Mixin extends base {\n        constructor(...args) {\n            super(...args);\n            this._disableRipple = false;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = coerceBooleanProperty(value); }\n    }\n    // Since we don't directly extend from `base` with it's original types, and we instruct\n    // TypeScript that `T` actually is instantiatable through `new`, the types don't overlap.\n    // This is a limitation in TS as abstract classes cannot be typed properly dynamically.\n    return Mixin;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `tabIndex` property. */\nfunction mixinTabIndex(base, defaultTabIndex = 0) {\n    // Note: We cast `base` to `unknown` and then `Constructor`. It could be an abstract class,\n    // but given we `extend` it from another class, we can assume a constructor being accessible.\n    class Mixin extends base {\n        constructor(...args) {\n            super(...args);\n            this._tabIndex = defaultTabIndex;\n            this.defaultTabIndex = defaultTabIndex;\n        }\n        get tabIndex() { return this.disabled ? -1 : this._tabIndex; }\n        set tabIndex(value) {\n            // If the specified tabIndex value is null or undefined, fall back to the default value.\n            this._tabIndex = value != null ? coerceNumberProperty(value) : this.defaultTabIndex;\n        }\n    }\n    // Since we don't directly extend from `base` with it's original types, and we instruct\n    // TypeScript that `T` actually is instantiatable through `new`, the types don't overlap.\n    // This is a limitation in TS as abstract classes cannot be typed properly dynamically.\n    return Mixin;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Mixin to augment a directive with updateErrorState method.\n * For component with `errorState` and need to update `errorState`.\n */\nfunction mixinErrorState(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            /** Whether the component is in an error state. */\n            this.errorState = false;\n            /**\n             * Stream that emits whenever the state of the input changes such that the wrapping\n             * `MatFormField` needs to run change detection.\n             */\n            this.stateChanges = new Subject[\"a\" /* Subject */]();\n        }\n        updateErrorState() {\n            const oldState = this.errorState;\n            const parent = this._parentFormGroup || this._parentForm;\n            const matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;\n            const control = this.ngControl ? this.ngControl.control : null;\n            const newState = matcher.isErrorState(control, parent);\n            if (newState !== oldState) {\n                this.errorState = newState;\n                this.stateChanges.next();\n            }\n        }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with an initialized property that will emits when ngOnInit ends. */\nfunction mixinInitialized(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            /** Whether this directive has been marked as initialized. */\n            this._isInitialized = false;\n            /**\n             * List of subscribers that subscribed before the directive was initialized. Should be notified\n             * during _markInitialized. Set to null after pending subscribers are notified, and should\n             * not expect to be populated after.\n             */\n            this._pendingSubscribers = [];\n            /**\n             * Observable stream that emits when the directive initializes. If already initialized, the\n             * subscriber is stored to be notified once _markInitialized is called.\n             */\n            this.initialized = new Observable[\"a\" /* Observable */](subscriber => {\n                // If initialized, immediately notify the subscriber. Otherwise store the subscriber to notify\n                // when _markInitialized is called.\n                if (this._isInitialized) {\n                    this._notifySubscriber(subscriber);\n                }\n                else {\n                    this._pendingSubscribers.push(subscriber);\n                }\n            });\n        }\n        /**\n         * Marks the state as initialized and notifies pending subscribers. Should be called at the end\n         * of ngOnInit.\n         * @docs-private\n         */\n        _markInitialized() {\n            if (this._isInitialized && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('This directive has already been marked as initialized and ' +\n                    'should not be called twice.');\n            }\n            this._isInitialized = true;\n            this._pendingSubscribers.forEach(this._notifySubscriber);\n            this._pendingSubscribers = null;\n        }\n        /** Emits and completes the subscriber stream (should only emit once). */\n        _notifySubscriber(subscriber) {\n            subscriber.next();\n            subscriber.complete();\n        }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** InjectionToken for datepicker that can be used to override default locale code. */\nconst MAT_DATE_LOCALE = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('MAT_DATE_LOCALE', {\n    providedIn: 'root',\n    factory: MAT_DATE_LOCALE_FACTORY,\n});\n/** @docs-private */\nfunction MAT_DATE_LOCALE_FACTORY() {\n    return Object(core[\"W\" /* inject */])(core[\"v\" /* LOCALE_ID */]);\n}\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\nclass core_DateAdapter {\n    constructor() {\n        this._localeChanges = new Subject[\"a\" /* Subject */]();\n        /** A stream that emits when the locale changes. */\n        this.localeChanges = this._localeChanges;\n    }\n    /**\n     * Given a potential date object, returns that same date object if it is\n     * a valid date, or `null` if it's not a valid date.\n     * @param obj The object to check.\n     * @returns A date or `null`.\n     */\n    getValidDateOrNull(obj) {\n        return this.isDateInstance(obj) && this.isValid(obj) ? obj : null;\n    }\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of its `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value) {\n        if (value == null || this.isDateInstance(value) && this.isValid(value)) {\n            return value;\n        }\n        return this.invalid();\n    }\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale) {\n        this.locale = locale;\n        this._localeChanges.next();\n    }\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first, second) {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second);\n    }\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first, second) {\n        if (first && second) {\n            let firstValid = this.isValid(first);\n            let secondValid = this.isValid(second);\n            if (firstValid && secondValid) {\n                return !this.compareDate(first, second);\n            }\n            return firstValid == secondValid;\n        }\n        return first == second;\n    }\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date, min, max) {\n        if (min && this.compareDate(date, min) < 0) {\n            return min;\n        }\n        if (max && this.compareDate(date, max) > 0) {\n            return max;\n        }\n        return date;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAT_DATE_FORMATS = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('mat-date-formats');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(mmalerba): Remove when we no longer support safari 9.\n/** Whether the browser supports the Intl API. */\nlet SUPPORTS_INTL_API;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    SUPPORTS_INTL_API = typeof Intl != 'undefined';\n}\ncatch (_a) {\n    SUPPORTS_INTL_API = false;\n}\n/** The default month names to use if Intl API is not available. */\nconst DEFAULT_MONTH_NAMES = {\n    'long': [\n        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',\n        'October', 'November', 'December'\n    ],\n    'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']\n};\nconst ɵ0 = i => String(i + 1);\n/** The default date names to use if Intl API is not available. */\nconst DEFAULT_DATE_NAMES = /*@__PURE__*/ range(31, ɵ0);\n/** The default day of the week names to use if Intl API is not available. */\nconst DEFAULT_DAY_OF_WEEK_NAMES = {\n    'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']\n};\n/**\n * Matches strings that have the form of a valid RFC 3339 string\n * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date\n * because the regex will match strings an with out of bounds month, date, etc.\n */\nconst ISO_8601_REGEX = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|(?:(?:\\+|-)\\d{2}:\\d{2}))?)?$/;\n/** Creates an array and fills it with values. */\nfunction range(length, valueFunction) {\n    const valuesArray = Array(length);\n    for (let i = 0; i < length; i++) {\n        valuesArray[i] = valueFunction(i);\n    }\n    return valuesArray;\n}\nlet core_NativeDateAdapter = /*@__PURE__*/ (() => {\n    class NativeDateAdapter extends core_DateAdapter {\n        constructor(matDateLocale, platform) {\n            super();\n            /**\n             * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.\n             * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off\n             * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`\n             * will produce `'8/13/1800'`.\n             *\n             * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now\n             * getting the string representation of a Date object from its utc representation. We're keeping\n             * it here for sometime, just for precaution, in case we decide to revert some of these changes\n             * though.\n             */\n            this.useUtcForDisplay = true;\n            super.setLocale(matDateLocale);\n            // IE does its own time zone correction, so we disable this on IE.\n            this.useUtcForDisplay = !platform.TRIDENT;\n            this._clampDate = platform.TRIDENT || platform.EDGE;\n        }\n        getYear(date) {\n            return date.getFullYear();\n        }\n        getMonth(date) {\n            return date.getMonth();\n        }\n        getDate(date) {\n            return date.getDate();\n        }\n        getDayOfWeek(date) {\n            return date.getDay();\n        }\n        getMonthNames(style) {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { month: style, timeZone: 'utc' });\n                return range(12, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, i, 1))));\n            }\n            return DEFAULT_MONTH_NAMES[style];\n        }\n        getDateNames() {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { day: 'numeric', timeZone: 'utc' });\n                return range(31, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n            }\n            return DEFAULT_DATE_NAMES;\n        }\n        getDayOfWeekNames(style) {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { weekday: style, timeZone: 'utc' });\n                return range(7, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n            }\n            return DEFAULT_DAY_OF_WEEK_NAMES[style];\n        }\n        getYearName(date) {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric', timeZone: 'utc' });\n                return this._stripDirectionalityCharacters(this._format(dtf, date));\n            }\n            return String(this.getYear(date));\n        }\n        getFirstDayOfWeek() {\n            // We can't tell using native JS Date what the first day of the week is, we default to Sunday.\n            return 0;\n        }\n        getNumDaysInMonth(date) {\n            return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\n        }\n        clone(date) {\n            return new Date(date.getTime());\n        }\n        createDate(year, month, date) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                // Check for invalid month and date (except upper bound on date which we have to check after\n                // creating the Date).\n                if (month < 0 || month > 11) {\n                    throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n                }\n                if (date < 1) {\n                    throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n                }\n            }\n            let result = this._createDateWithOverflow(year, month, date);\n            // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n            if (result.getMonth() != month && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n            }\n            return result;\n        }\n        today() {\n            return new Date();\n        }\n        parse(value) {\n            // We have no way using the native JS Date to set the parse format or locale, so we ignore these\n            // parameters.\n            if (typeof value == 'number') {\n                return new Date(value);\n            }\n            return value ? new Date(Date.parse(value)) : null;\n        }\n        format(date, displayFormat) {\n            if (!this.isValid(date)) {\n                throw Error('NativeDateAdapter: Cannot format invalid date.');\n            }\n            if (SUPPORTS_INTL_API) {\n                // On IE and Edge the i18n API will throw a hard error that can crash the entire app\n                // if we attempt to format a date whose year is less than 1 or greater than 9999.\n                if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {\n                    date = this.clone(date);\n                    date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));\n                }\n                displayFormat = Object.assign(Object.assign({}, displayFormat), { timeZone: 'utc' });\n                const dtf = new Intl.DateTimeFormat(this.locale, displayFormat);\n                return this._stripDirectionalityCharacters(this._format(dtf, date));\n            }\n            return this._stripDirectionalityCharacters(date.toDateString());\n        }\n        addCalendarYears(date, years) {\n            return this.addCalendarMonths(date, years * 12);\n        }\n        addCalendarMonths(date, months) {\n            let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));\n            // It's possible to wind up in the wrong month if the original month has more days than the new\n            // month. In this case we want to go to the last day of the desired month.\n            // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't\n            // guarantee this.\n            if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {\n                newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\n            }\n            return newDate;\n        }\n        addCalendarDays(date, days) {\n            return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);\n        }\n        toIso8601(date) {\n            return [\n                date.getUTCFullYear(),\n                this._2digit(date.getUTCMonth() + 1),\n                this._2digit(date.getUTCDate())\n            ].join('-');\n        }\n        /**\n         * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\n         * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\n         * invalid date for all other values.\n         */\n        deserialize(value) {\n            if (typeof value === 'string') {\n                if (!value) {\n                    return null;\n                }\n                // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the\n                // string is the right format first.\n                if (ISO_8601_REGEX.test(value)) {\n                    let date = new Date(value);\n                    if (this.isValid(date)) {\n                        return date;\n                    }\n                }\n            }\n            return super.deserialize(value);\n        }\n        isDateInstance(obj) {\n            return obj instanceof Date;\n        }\n        isValid(date) {\n            return !isNaN(date.getTime());\n        }\n        invalid() {\n            return new Date(NaN);\n        }\n        /** Creates a date but allows the month and date to overflow. */\n        _createDateWithOverflow(year, month, date) {\n            // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n            // To work around this we use `setFullYear` and `setHours` instead.\n            const d = new Date();\n            d.setFullYear(year, month, date);\n            d.setHours(0, 0, 0, 0);\n            return d;\n        }\n        /**\n         * Pads a number to make it two digits.\n         * @param n The number to pad.\n         * @returns The padded number.\n         */\n        _2digit(n) {\n            return ('00' + n).slice(-2);\n        }\n        /**\n         * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\n         * other browsers do not. We remove them to make output consistent and because they interfere with\n         * date parsing.\n         * @param str The string to strip direction characters from.\n         * @returns The stripped string.\n         */\n        _stripDirectionalityCharacters(str) {\n            return str.replace(/[\\u200e\\u200f]/g, '');\n        }\n        /**\n         * When converting Date object to string, javascript built-in functions may return wrong\n         * results because it applies its internal DST rules. The DST rules around the world change\n         * very frequently, and the current valid rule is not always valid in previous years though.\n         * We work around this problem building a new Date object which has its internal UTC\n         * representation with the local date and time.\n         * @param dtf Intl.DateTimeFormat object, containg the desired string format. It must have\n         *    timeZone set to 'utc' to work fine.\n         * @param date Date from which we want to get the string representation according to dtf\n         * @returns A Date object with its UTC representation based on the passed in date info\n         */\n        _format(dtf, date) {\n            // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n            // To work around this we use `setUTCFullYear` and `setUTCHours` instead.\n            const d = new Date();\n            d.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n            d.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n            return dtf.format(d);\n        }\n    }\n    NativeDateAdapter.ɵfac = function NativeDateAdapter_Factory(t) { return new (t || NativeDateAdapter)(core[\"bc\" /* ɵɵinject */](MAT_DATE_LOCALE, 8), core[\"bc\" /* ɵɵinject */](platform_Platform)); };\n    NativeDateAdapter.ɵprov = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineInjectable */]({ token: NativeDateAdapter, factory: NativeDateAdapter.ɵfac });\n    return NativeDateAdapter;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAT_NATIVE_DATE_FORMATS = {\n    parse: {\n        dateInput: null,\n    },\n    display: {\n        dateInput: { year: 'numeric', month: 'numeric', day: 'numeric' },\n        monthYearLabel: { year: 'numeric', month: 'short' },\n        dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },\n        monthYearA11yLabel: { year: 'numeric', month: 'long' },\n    }\n};\nlet core_NativeDateModule = /*@__PURE__*/ (() => {\n    class NativeDateModule {\n    }\n    NativeDateModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: NativeDateModule });\n    NativeDateModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function NativeDateModule_Factory(t) { return new (t || NativeDateModule)(); }, providers: [\n            { provide: core_DateAdapter, useClass: core_NativeDateAdapter },\n        ], imports: [[platform_PlatformModule]] });\n    return NativeDateModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](core_NativeDateModule, { imports: function () { return [platform_PlatformModule]; } }); })();\nconst ɵ0$1 = MAT_NATIVE_DATE_FORMATS;\nlet core_MatNativeDateModule = /*@__PURE__*/ (() => {\n    class MatNativeDateModule {\n    }\n    MatNativeDateModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: MatNativeDateModule });\n    MatNativeDateModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function MatNativeDateModule_Factory(t) { return new (t || MatNativeDateModule)(); }, providers: [{ provide: MAT_DATE_FORMATS, useValue: ɵ0$1 }], imports: [[core_NativeDateModule]] });\n    return MatNativeDateModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](core_MatNativeDateModule, { imports: [core_NativeDateModule] }); })();\nlet core_ShowOnDirtyErrorStateMatcher = /*@__PURE__*/ (() => {\n    class ShowOnDirtyErrorStateMatcher {\n        isErrorState(control, form) {\n            return !!(control && control.invalid && (control.dirty || (form && form.submitted)));\n        }\n    }\n    ShowOnDirtyErrorStateMatcher.ɵfac = function ShowOnDirtyErrorStateMatcher_Factory(t) { return new (t || ShowOnDirtyErrorStateMatcher)(); };\n    ShowOnDirtyErrorStateMatcher.ɵprov = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineInjectable */]({ token: ShowOnDirtyErrorStateMatcher, factory: ShowOnDirtyErrorStateMatcher.ɵfac });\n    return ShowOnDirtyErrorStateMatcher;\n})();\nlet core_ErrorStateMatcher = /*@__PURE__*/ (() => {\n    class ErrorStateMatcher {\n        isErrorState(control, form) {\n            return !!(control && control.invalid && (control.touched || (form && form.submitted)));\n        }\n    }\n    ErrorStateMatcher.ɵfac = function ErrorStateMatcher_Factory(t) { return new (t || ErrorStateMatcher)(); };\n    ErrorStateMatcher.ɵprov = /*@__PURE__*/ Object(core[\"Kb\" /* ɵɵdefineInjectable */])({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: \"root\" });\n    return ErrorStateMatcher;\n})();\nlet core_MatLine = /*@__PURE__*/ (() => {\n    class MatLine {\n    }\n    MatLine.ɵfac = function MatLine_Factory(t) { return new (t || MatLine)(); };\n    MatLine.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: MatLine, selectors: [[\"\", \"mat-line\", \"\"], [\"\", \"matLine\", \"\"]], hostAttrs: [1, \"mat-line\"] });\n    return MatLine;\n})();\n/**\n * Helper that takes a query list of lines and sets the correct class on the host.\n * @docs-private\n */\nfunction setLines(lines, element, prefix = 'mat') {\n    // Note: doesn't need to unsubscribe, because `changes`\n    // gets completed by Angular when the view is destroyed.\n    lines.changes.pipe(Object(startWith[\"a\" /* startWith */])(lines)).subscribe(({ length }) => {\n        setClass(element, `${prefix}-2-line`, false);\n        setClass(element, `${prefix}-3-line`, false);\n        setClass(element, `${prefix}-multi-line`, false);\n        if (length === 2 || length === 3) {\n            setClass(element, `${prefix}-${length}-line`, true);\n        }\n        else if (length > 3) {\n            setClass(element, `${prefix}-multi-line`, true);\n        }\n    });\n}\n/** Adds or removes a class from an element. */\nfunction setClass(element, className, isAdd) {\n    const classList = element.nativeElement.classList;\n    isAdd ? classList.add(className) : classList.remove(className);\n}\nlet core_MatLineModule = /*@__PURE__*/ (() => {\n    class MatLineModule {\n    }\n    MatLineModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: MatLineModule });\n    MatLineModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function MatLineModule_Factory(t) { return new (t || MatLineModule)(); }, imports: [[core_MatCommonModule], core_MatCommonModule] });\n    return MatLineModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](core_MatLineModule, { declarations: [core_MatLine], imports: [core_MatCommonModule], exports: [core_MatLine, core_MatCommonModule] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Reference to a previously launched ripple element.\n */\nclass RippleRef {\n    constructor(_renderer, \n    /** Reference to the ripple HTML element. */\n    element, \n    /** Ripple configuration used for the ripple. */\n    config) {\n        this._renderer = _renderer;\n        this.element = element;\n        this.config = config;\n        /** Current state of the ripple. */\n        this.state = 3 /* HIDDEN */;\n    }\n    /** Fades out the ripple element. */\n    fadeOut() {\n        this._renderer.fadeOutRipple(this);\n    }\n}\n/**\n * Default ripple animation configuration for ripples without an explicit\n * animation config specified.\n */\nconst defaultRippleAnimationConfig = {\n    enterDuration: 450,\n    exitDuration: 400\n};\n/**\n * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch\n * events to avoid synthetic mouse events.\n */\nconst ignoreMouseEventsTimeout = 800;\n/** Options that apply to all the event listeners that are bound by the ripple renderer. */\nconst passiveEventOptions = /*@__PURE__*/ normalizePassiveListenerOptions({ passive: true });\n/** Events that signal that the pointer is down. */\nconst pointerDownEvents = ['mousedown', 'touchstart'];\n/** Events that signal that the pointer is up. */\nconst pointerUpEvents = ['mouseup', 'mouseleave', 'touchend', 'touchcancel'];\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * @docs-private\n */\nclass core_RippleRenderer {\n    constructor(_target, _ngZone, elementOrElementRef, platform) {\n        this._target = _target;\n        this._ngZone = _ngZone;\n        /** Whether the pointer is currently down or not. */\n        this._isPointerDown = false;\n        /** Set of currently active ripple references. */\n        this._activeRipples = new Set();\n        /** Whether pointer-up event listeners have been registered. */\n        this._pointerUpEventsRegistered = false;\n        // Only do anything if we're on the browser.\n        if (platform.isBrowser) {\n            this._containerElement = coerceElement(elementOrElementRef);\n        }\n    }\n    /**\n     * Fades in a ripple at the given coordinates.\n     * @param x Coordinate within the element, along the X axis at which to start the ripple.\n     * @param y Coordinate within the element, along the Y axis at which to start the ripple.\n     * @param config Extra ripple options.\n     */\n    fadeInRipple(x, y, config = {}) {\n        const containerRect = this._containerRect =\n            this._containerRect || this._containerElement.getBoundingClientRect();\n        const animationConfig = Object.assign(Object.assign({}, defaultRippleAnimationConfig), config.animation);\n        if (config.centered) {\n            x = containerRect.left + containerRect.width / 2;\n            y = containerRect.top + containerRect.height / 2;\n        }\n        const radius = config.radius || distanceToFurthestCorner(x, y, containerRect);\n        const offsetX = x - containerRect.left;\n        const offsetY = y - containerRect.top;\n        const duration = animationConfig.enterDuration;\n        const ripple = document.createElement('div');\n        ripple.classList.add('mat-ripple-element');\n        ripple.style.left = `${offsetX - radius}px`;\n        ripple.style.top = `${offsetY - radius}px`;\n        ripple.style.height = `${radius * 2}px`;\n        ripple.style.width = `${radius * 2}px`;\n        // If a custom color has been specified, set it as inline style. If no color is\n        // set, the default color will be applied through the ripple theme styles.\n        if (config.color != null) {\n            ripple.style.backgroundColor = config.color;\n        }\n        ripple.style.transitionDuration = `${duration}ms`;\n        this._containerElement.appendChild(ripple);\n        // By default the browser does not recalculate the styles of dynamically created\n        // ripple elements. This is critical because then the `scale` would not animate properly.\n        enforceStyleRecalculation(ripple);\n        ripple.style.transform = 'scale(1)';\n        // Exposed reference to the ripple that will be returned.\n        const rippleRef = new RippleRef(this, ripple, config);\n        rippleRef.state = 0 /* FADING_IN */;\n        // Add the ripple reference to the list of all active ripples.\n        this._activeRipples.add(rippleRef);\n        if (!config.persistent) {\n            this._mostRecentTransientRipple = rippleRef;\n        }\n        // Wait for the ripple element to be completely faded in.\n        // Once it's faded in, the ripple can be hidden immediately if the mouse is released.\n        this._runTimeoutOutsideZone(() => {\n            const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;\n            rippleRef.state = 1 /* VISIBLE */;\n            // When the timer runs out while the user has kept their pointer down, we want to\n            // keep only the persistent ripples and the latest transient ripple. We do this,\n            // because we don't want stacked transient ripples to appear after their enter\n            // animation has finished.\n            if (!config.persistent && (!isMostRecentTransientRipple || !this._isPointerDown)) {\n                rippleRef.fadeOut();\n            }\n        }, duration);\n        return rippleRef;\n    }\n    /** Fades out a ripple reference. */\n    fadeOutRipple(rippleRef) {\n        const wasActive = this._activeRipples.delete(rippleRef);\n        if (rippleRef === this._mostRecentTransientRipple) {\n            this._mostRecentTransientRipple = null;\n        }\n        // Clear out the cached bounding rect if we have no more ripples.\n        if (!this._activeRipples.size) {\n            this._containerRect = null;\n        }\n        // For ripples that are not active anymore, don't re-run the fade-out animation.\n        if (!wasActive) {\n            return;\n        }\n        const rippleEl = rippleRef.element;\n        const animationConfig = Object.assign(Object.assign({}, defaultRippleAnimationConfig), rippleRef.config.animation);\n        rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`;\n        rippleEl.style.opacity = '0';\n        rippleRef.state = 2 /* FADING_OUT */;\n        // Once the ripple faded out, the ripple can be safely removed from the DOM.\n        this._runTimeoutOutsideZone(() => {\n            rippleRef.state = 3 /* HIDDEN */;\n            rippleEl.parentNode.removeChild(rippleEl);\n        }, animationConfig.exitDuration);\n    }\n    /** Fades out all currently active ripples. */\n    fadeOutAll() {\n        this._activeRipples.forEach(ripple => ripple.fadeOut());\n    }\n    /** Sets up the trigger event listeners */\n    setupTriggerEvents(elementOrElementRef) {\n        const element = coerceElement(elementOrElementRef);\n        if (!element || element === this._triggerElement) {\n            return;\n        }\n        // Remove all previously registered event listeners from the trigger element.\n        this._removeTriggerEvents();\n        this._triggerElement = element;\n        this._registerEvents(pointerDownEvents);\n    }\n    /**\n     * Handles all registered events.\n     * @docs-private\n     */\n    handleEvent(event) {\n        if (event.type === 'mousedown') {\n            this._onMousedown(event);\n        }\n        else if (event.type === 'touchstart') {\n            this._onTouchStart(event);\n        }\n        else {\n            this._onPointerUp();\n        }\n        // If pointer-up events haven't been registered yet, do so now.\n        // We do this on-demand in order to reduce the total number of event listeners\n        // registered by the ripples, which speeds up the rendering time for large UIs.\n        if (!this._pointerUpEventsRegistered) {\n            this._registerEvents(pointerUpEvents);\n            this._pointerUpEventsRegistered = true;\n        }\n    }\n    /** Function being called whenever the trigger is being pressed using mouse. */\n    _onMousedown(event) {\n        // Screen readers will fire fake mouse events for space/enter. Skip launching a\n        // ripple in this case for consistency with the non-screen-reader experience.\n        const isFakeMousedown = isFakeMousedownFromScreenReader(event);\n        const isSyntheticEvent = this._lastTouchStartEvent &&\n            Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;\n        if (!this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {\n            this._isPointerDown = true;\n            this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig);\n        }\n    }\n    /** Function being called whenever the trigger is being pressed using touch. */\n    _onTouchStart(event) {\n        if (!this._target.rippleDisabled && !isFakeTouchstartFromScreenReader(event)) {\n            // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse\n            // events will launch a second ripple if we don't ignore mouse events for a specific\n            // time after a touchstart event.\n            this._lastTouchStartEvent = Date.now();\n            this._isPointerDown = true;\n            // Use `changedTouches` so we skip any touches where the user put\n            // their finger down, but used another finger to tap the element again.\n            const touches = event.changedTouches;\n            for (let i = 0; i < touches.length; i++) {\n                this.fadeInRipple(touches[i].clientX, touches[i].clientY, this._target.rippleConfig);\n            }\n        }\n    }\n    /** Function being called whenever the trigger is being released. */\n    _onPointerUp() {\n        if (!this._isPointerDown) {\n            return;\n        }\n        this._isPointerDown = false;\n        // Fade-out all ripples that are visible and not persistent.\n        this._activeRipples.forEach(ripple => {\n            // By default, only ripples that are completely visible will fade out on pointer release.\n            // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.\n            const isVisible = ripple.state === 1 /* VISIBLE */ ||\n                ripple.config.terminateOnPointerUp && ripple.state === 0 /* FADING_IN */;\n            if (!ripple.config.persistent && isVisible) {\n                ripple.fadeOut();\n            }\n        });\n    }\n    /** Runs a timeout outside of the Angular zone to avoid triggering the change detection. */\n    _runTimeoutOutsideZone(fn, delay = 0) {\n        this._ngZone.runOutsideAngular(() => setTimeout(fn, delay));\n    }\n    /** Registers event listeners for a given list of events. */\n    _registerEvents(eventTypes) {\n        this._ngZone.runOutsideAngular(() => {\n            eventTypes.forEach((type) => {\n                this._triggerElement.addEventListener(type, this, passiveEventOptions);\n            });\n        });\n    }\n    /** Removes previously registered event listeners from the trigger element. */\n    _removeTriggerEvents() {\n        if (this._triggerElement) {\n            pointerDownEvents.forEach((type) => {\n                this._triggerElement.removeEventListener(type, this, passiveEventOptions);\n            });\n            if (this._pointerUpEventsRegistered) {\n                pointerUpEvents.forEach((type) => {\n                    this._triggerElement.removeEventListener(type, this, passiveEventOptions);\n                });\n            }\n        }\n    }\n}\n/** Enforces a style recalculation of a DOM element by computing its styles. */\nfunction enforceStyleRecalculation(element) {\n    // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.\n    // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.\n    // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n    window.getComputedStyle(element).getPropertyValue('opacity');\n}\n/**\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\n */\nfunction distanceToFurthestCorner(x, y, rect) {\n    const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n    const distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n    return Math.sqrt(distX * distX + distY * distY);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token that can be used to specify the global ripple options. */\nconst MAT_RIPPLE_GLOBAL_OPTIONS = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('mat-ripple-global-options');\nlet core_MatRipple = /*@__PURE__*/ (() => {\n    class MatRipple {\n        constructor(_elementRef, ngZone, platform, globalOptions, _animationMode) {\n            this._elementRef = _elementRef;\n            this._animationMode = _animationMode;\n            /**\n             * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\n             * will be the distance from the center of the ripple to the furthest corner of the host element's\n             * bounding rectangle.\n             */\n            this.radius = 0;\n            this._disabled = false;\n            /** Whether ripple directive is initialized and the input bindings are set. */\n            this._isInitialized = false;\n            this._globalOptions = globalOptions || {};\n            this._rippleRenderer = new core_RippleRenderer(this, ngZone, _elementRef, platform);\n        }\n        /**\n         * Whether click events will not trigger the ripple. Ripples can be still launched manually\n         * by using the `launch()` method.\n         */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            this._disabled = value;\n            this._setupTriggerEventsIfEnabled();\n        }\n        /**\n         * The element that triggers the ripple when click events are received.\n         * Defaults to the directive's host element.\n         */\n        get trigger() { return this._trigger || this._elementRef.nativeElement; }\n        set trigger(trigger) {\n            this._trigger = trigger;\n            this._setupTriggerEventsIfEnabled();\n        }\n        ngOnInit() {\n            this._isInitialized = true;\n            this._setupTriggerEventsIfEnabled();\n        }\n        ngOnDestroy() {\n            this._rippleRenderer._removeTriggerEvents();\n        }\n        /** Fades out all currently showing ripple elements. */\n        fadeOutAll() {\n            this._rippleRenderer.fadeOutAll();\n        }\n        /**\n         * Ripple configuration from the directive's input values.\n         * @docs-private Implemented as part of RippleTarget\n         */\n        get rippleConfig() {\n            return {\n                centered: this.centered,\n                radius: this.radius,\n                color: this.color,\n                animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), (this._animationMode === 'NoopAnimations' ? { enterDuration: 0, exitDuration: 0 } : {})), this.animation),\n                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,\n            };\n        }\n        /**\n         * Whether ripples on pointer-down are disabled or not.\n         * @docs-private Implemented as part of RippleTarget\n         */\n        get rippleDisabled() {\n            return this.disabled || !!this._globalOptions.disabled;\n        }\n        /** Sets up the trigger event listeners if ripples are enabled. */\n        _setupTriggerEventsIfEnabled() {\n            if (!this.disabled && this._isInitialized) {\n                this._rippleRenderer.setupTriggerEvents(this.trigger);\n            }\n        }\n        /** Launches a manual ripple at the specified coordinated or just by the ripple config. */\n        launch(configOrX, y = 0, config) {\n            if (typeof configOrX === 'number') {\n                return this._rippleRenderer.fadeInRipple(configOrX, y, Object.assign(Object.assign({}, this.rippleConfig), config));\n            }\n            else {\n                return this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), configOrX));\n            }\n        }\n    }\n    MatRipple.ɵfac = function MatRipple_Factory(t) { return new (t || MatRipple)(core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Ob\" /* ɵɵdirectiveInject */](platform_Platform), core[\"Ob\" /* ɵɵdirectiveInject */](MAT_RIPPLE_GLOBAL_OPTIONS, 8), core[\"Ob\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatRipple.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: MatRipple, selectors: [[\"\", \"mat-ripple\", \"\"], [\"\", \"matRipple\", \"\"]], hostAttrs: [1, \"mat-ripple\"], hostVars: 2, hostBindings: function MatRipple_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Gb\" /* ɵɵclassProp */](\"mat-ripple-unbounded\", ctx.unbounded);\n            }\n        }, inputs: { radius: [\"matRippleRadius\", \"radius\"], disabled: [\"matRippleDisabled\", \"disabled\"], trigger: [\"matRippleTrigger\", \"trigger\"], color: [\"matRippleColor\", \"color\"], unbounded: [\"matRippleUnbounded\", \"unbounded\"], centered: [\"matRippleCentered\", \"centered\"], animation: [\"matRippleAnimation\", \"animation\"] }, exportAs: [\"matRipple\"] });\n    return MatRipple;\n})();\nlet core_MatRippleModule = /*@__PURE__*/ (() => {\n    class MatRippleModule {\n    }\n    MatRippleModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: MatRippleModule });\n    MatRippleModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function MatRippleModule_Factory(t) { return new (t || MatRippleModule)(); }, imports: [[core_MatCommonModule, platform_PlatformModule], core_MatCommonModule] });\n    return MatRippleModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](core_MatRippleModule, { declarations: function () { return [core_MatRipple]; }, imports: function () { return [core_MatCommonModule, platform_PlatformModule]; }, exports: function () { return [core_MatRipple, core_MatCommonModule]; } }); })();\nlet core_MatPseudoCheckbox = /*@__PURE__*/ (() => {\n    class MatPseudoCheckbox {\n        constructor(_animationMode) {\n            this._animationMode = _animationMode;\n            /** Display state of the checkbox. */\n            this.state = 'unchecked';\n            /** Whether the checkbox is disabled. */\n            this.disabled = false;\n        }\n    }\n    MatPseudoCheckbox.ɵfac = function MatPseudoCheckbox_Factory(t) { return new (t || MatPseudoCheckbox)(core[\"Ob\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatPseudoCheckbox.ɵcmp = /*@__PURE__*/ core[\"Ib\" /* ɵɵdefineComponent */]({ type: MatPseudoCheckbox, selectors: [[\"mat-pseudo-checkbox\"]], hostAttrs: [1, \"mat-pseudo-checkbox\"], hostVars: 8, hostBindings: function MatPseudoCheckbox_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Gb\" /* ɵɵclassProp */](\"mat-pseudo-checkbox-indeterminate\", ctx.state === \"indeterminate\")(\"mat-pseudo-checkbox-checked\", ctx.state === \"checked\")(\"mat-pseudo-checkbox-disabled\", ctx.disabled)(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n            }\n        }, inputs: { state: \"state\", disabled: \"disabled\" }, decls: 0, vars: 0, template: function MatPseudoCheckbox_Template(rf, ctx) { }, styles: [\".mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:\\\"\\\";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatPseudoCheckbox;\n})();\nlet core_MatPseudoCheckboxModule = /*@__PURE__*/ (() => {\n    class MatPseudoCheckboxModule {\n    }\n    MatPseudoCheckboxModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: MatPseudoCheckboxModule });\n    MatPseudoCheckboxModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function MatPseudoCheckboxModule_Factory(t) { return new (t || MatPseudoCheckboxModule)(); }, imports: [[core_MatCommonModule]] });\n    return MatPseudoCheckboxModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](core_MatPseudoCheckboxModule, { declarations: [core_MatPseudoCheckbox], imports: [core_MatCommonModule], exports: [core_MatPseudoCheckbox] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to provide the parent component to options.\n */\nconst MAT_OPTION_PARENT_COMPONENT = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('MAT_OPTION_PARENT_COMPONENT');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Notes on the accessibility pattern used for `mat-optgroup`.\n// The option group has two different \"modes\": regular and inert. The regular mode uses the\n// recommended a11y pattern which has `role=\"group\"` on the group element with `aria-labelledby`\n// pointing to the label. This works for `mat-select`, but it seems to hit a bug for autocomplete\n// under VoiceOver where the group doesn't get read out at all. The bug appears to be that if\n// there's __any__ a11y-related attribute on the group (e.g. `role` or `aria-labelledby`),\n// VoiceOver on Safari won't read it out.\n// We've introduced the `inert` mode as a workaround. Under this mode, all a11y attributes are\n// removed from the group, and we get the screen reader to read out the group label by mirroring it\n// inside an invisible element in the option. This is sub-optimal, because the screen reader will\n// repeat the group label on each navigation, whereas the default pattern only reads the group when\n// the user enters a new group. The following alternate approaches were considered:\n// 1. Reading out the group label using the `LiveAnnouncer` solves the problem, but we can't control\n//    when the text will be read out so sometimes it comes in too late or never if the user\n//    navigates quickly.\n// 2. `<mat-option aria-describedby=\"groupLabel\"` - This works on Safari, but VoiceOver in Chrome\n//    won't read out the description at all.\n// 3. `<mat-option aria-labelledby=\"optionLabel groupLabel\"` - This works on Chrome, but Safari\n//     doesn't read out the text at all. Furthermore, on\n// Boilerplate for applying mixins to MatOptgroup.\n/** @docs-private */\nclass MatOptgroupBase {\n}\nconst _MatOptgroupMixinBase = /*@__PURE__*/ mixinDisabled(MatOptgroupBase);\n// Counter for unique group ids.\nlet _uniqueOptgroupIdCounter = 0;\nlet core_MatOptgroupBase = /*@__PURE__*/ (() => {\n    class _MatOptgroupBase extends _MatOptgroupMixinBase {\n        constructor(parent) {\n            var _a;\n            super();\n            /** Unique id for the underlying label. */\n            this._labelId = `mat-optgroup-label-${_uniqueOptgroupIdCounter++}`;\n            this._inert = (_a = parent === null || parent === void 0 ? void 0 : parent.inertGroups) !== null && _a !== void 0 ? _a : false;\n        }\n    }\n    _MatOptgroupBase.ɵfac = function _MatOptgroupBase_Factory(t) { return new (t || _MatOptgroupBase)(core[\"Ob\" /* ɵɵdirectiveInject */](MAT_OPTION_PARENT_COMPONENT, 8)); };\n    _MatOptgroupBase.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: _MatOptgroupBase, inputs: { label: \"label\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return _MatOptgroupBase;\n})();\n/**\n * Injection token that can be used to reference instances of `MatOptgroup`. It serves as\n * alternative token to the actual `MatOptgroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nconst MAT_OPTGROUP = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('MatOptgroup');\nlet core_MatOptgroup = /*@__PURE__*/ (() => {\n    class MatOptgroup extends core_MatOptgroupBase {\n    }\n    MatOptgroup.ɵfac = function MatOptgroup_Factory(t) { return ɵMatOptgroup_BaseFactory(t || MatOptgroup); };\n    MatOptgroup.ɵcmp = /*@__PURE__*/ core[\"Ib\" /* ɵɵdefineComponent */]({ type: MatOptgroup, selectors: [[\"mat-optgroup\"]], hostAttrs: [1, \"mat-optgroup\"], hostVars: 5, hostBindings: function MatOptgroup_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Db\" /* ɵɵattribute */](\"role\", ctx._inert ? null : \"group\")(\"aria-disabled\", ctx._inert ? null : ctx.disabled.toString())(\"aria-labelledby\", ctx._inert ? null : ctx._labelId);\n                core[\"Gb\" /* ɵɵclassProp */](\"mat-optgroup-disabled\", ctx.disabled);\n            }\n        }, inputs: { disabled: \"disabled\" }, exportAs: [\"matOptgroup\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: MAT_OPTGROUP, useExisting: MatOptgroup }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c1, decls: 4, vars: 2, consts: [[\"aria-hidden\", \"true\", 1, \"mat-optgroup-label\", 3, \"id\"]], template: function MatOptgroup_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"nc\" /* ɵɵprojectionDef */](_c0);\n                core[\"Ub\" /* ɵɵelementStart */](0, \"span\", 0);\n                core[\"Hc\" /* ɵɵtext */](1);\n                core[\"mc\" /* ɵɵprojection */](2);\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"mc\" /* ɵɵprojection */](3, 1);\n            }\n            if (rf & 2) {\n                core[\"oc\" /* ɵɵproperty */](\"id\", ctx._labelId);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"Jc\" /* ɵɵtextInterpolate1 */](\"\", ctx.label, \" \");\n            }\n        }, styles: [\".mat-optgroup-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup-label[disabled]{cursor:default}[dir=rtl] .mat-optgroup-label{text-align:right}.mat-optgroup-label .mat-icon{margin-right:16px;vertical-align:middle}.mat-optgroup-label .mat-icon svg{vertical-align:top}[dir=rtl] .mat-optgroup-label .mat-icon{margin-left:16px;margin-right:0}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatOptgroup;\n})();\nconst ɵMatOptgroup_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Wb\" /* ɵɵgetInheritedFactory */](core_MatOptgroup);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Option IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueIdCounter = 0;\n/** Event object emitted by MatOption when selected or deselected. */\nclass MatOptionSelectionChange {\n    constructor(\n    /** Reference to the option that emitted the event. */\n    source, \n    /** Whether the change in the option's value was a result of a user action. */\n    isUserInput = false) {\n        this.source = source;\n        this.isUserInput = isUserInput;\n    }\n}\nlet core_MatOptionBase = /*@__PURE__*/ (() => {\n    class _MatOptionBase {\n        constructor(_element, _changeDetectorRef, _parent, group) {\n            this._element = _element;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._parent = _parent;\n            this.group = group;\n            this._selected = false;\n            this._active = false;\n            this._disabled = false;\n            this._mostRecentViewValue = '';\n            /** The unique ID of the option. */\n            this.id = `mat-option-${_uniqueIdCounter++}`;\n            /** Event emitted when the option is selected or deselected. */\n            // tslint:disable-next-line:no-output-on-prefix\n            this.onSelectionChange = new core[\"n\" /* EventEmitter */]();\n            /** Emits when the state of the option changes and any parents have to be notified. */\n            this._stateChanges = new Subject[\"a\" /* Subject */]();\n        }\n        /** Whether the wrapping component is in multiple selection mode. */\n        get multiple() { return this._parent && this._parent.multiple; }\n        /** Whether or not the option is currently selected. */\n        get selected() { return this._selected; }\n        /** Whether the option is disabled. */\n        get disabled() { return (this.group && this.group.disabled) || this._disabled; }\n        set disabled(value) { this._disabled = coerceBooleanProperty(value); }\n        /** Whether ripples for the option are disabled. */\n        get disableRipple() { return this._parent && this._parent.disableRipple; }\n        /**\n         * Whether or not the option is currently active and ready to be selected.\n         * An active option displays styles as if it is focused, but the\n         * focus is actually retained somewhere else. This comes in handy\n         * for components like autocomplete where focus must remain on the input.\n         */\n        get active() {\n            return this._active;\n        }\n        /**\n         * The displayed value of the option. It is necessary to show the selected option in the\n         * select's trigger.\n         */\n        get viewValue() {\n            // TODO(kara): Add input property alternative for node envs.\n            return (this._getHostElement().textContent || '').trim();\n        }\n        /** Selects the option. */\n        select() {\n            if (!this._selected) {\n                this._selected = true;\n                this._changeDetectorRef.markForCheck();\n                this._emitSelectionChangeEvent();\n            }\n        }\n        /** Deselects the option. */\n        deselect() {\n            if (this._selected) {\n                this._selected = false;\n                this._changeDetectorRef.markForCheck();\n                this._emitSelectionChangeEvent();\n            }\n        }\n        /** Sets focus onto this option. */\n        focus(_origin, options) {\n            // Note that we aren't using `_origin`, but we need to keep it because some internal consumers\n            // use `MatOption` in a `FocusKeyManager` and we need it to match `FocusableOption`.\n            const element = this._getHostElement();\n            if (typeof element.focus === 'function') {\n                element.focus(options);\n            }\n        }\n        /**\n         * This method sets display styles on the option to make it appear\n         * active. This is used by the ActiveDescendantKeyManager so key\n         * events will display the proper options as active on arrow key events.\n         */\n        setActiveStyles() {\n            if (!this._active) {\n                this._active = true;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * This method removes display styles on the option that made it appear\n         * active. This is used by the ActiveDescendantKeyManager so key\n         * events will display the proper options as active on arrow key events.\n         */\n        setInactiveStyles() {\n            if (this._active) {\n                this._active = false;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /** Gets the label to be used when determining whether the option should be focused. */\n        getLabel() {\n            return this.viewValue;\n        }\n        /** Ensures the option is selected when activated from the keyboard. */\n        _handleKeydown(event) {\n            if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {\n                this._selectViaInteraction();\n                // Prevent the page from scrolling down and form submits.\n                event.preventDefault();\n            }\n        }\n        /**\n         * `Selects the option while indicating the selection came from the user. Used to\n         * determine if the select's view -> model callback should be invoked.`\n         */\n        _selectViaInteraction() {\n            if (!this.disabled) {\n                this._selected = this.multiple ? !this._selected : true;\n                this._changeDetectorRef.markForCheck();\n                this._emitSelectionChangeEvent(true);\n            }\n        }\n        /**\n         * Gets the `aria-selected` value for the option. We explicitly omit the `aria-selected`\n         * attribute from single-selection, unselected options. Including the `aria-selected=\"false\"`\n         * attributes adds a significant amount of noise to screen-reader users without providing useful\n         * information.\n         */\n        _getAriaSelected() {\n            return this.selected || (this.multiple ? false : null);\n        }\n        /** Returns the correct tabindex for the option depending on disabled state. */\n        _getTabIndex() {\n            return this.disabled ? '-1' : '0';\n        }\n        /** Gets the host DOM element. */\n        _getHostElement() {\n            return this._element.nativeElement;\n        }\n        ngAfterViewChecked() {\n            // Since parent components could be using the option's label to display the selected values\n            // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed\n            // we have to check for changes in the DOM ourselves and dispatch an event. These checks are\n            // relatively cheap, however we still limit them only to selected options in order to avoid\n            // hitting the DOM too often.\n            if (this._selected) {\n                const viewValue = this.viewValue;\n                if (viewValue !== this._mostRecentViewValue) {\n                    this._mostRecentViewValue = viewValue;\n                    this._stateChanges.next();\n                }\n            }\n        }\n        ngOnDestroy() {\n            this._stateChanges.complete();\n        }\n        /** Emits the selection change event. */\n        _emitSelectionChangeEvent(isUserInput = false) {\n            this.onSelectionChange.emit(new MatOptionSelectionChange(this, isUserInput));\n        }\n    }\n    _MatOptionBase.ɵfac = function _MatOptionBase_Factory(t) { return new (t || _MatOptionBase)(core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](undefined), core[\"Ob\" /* ɵɵdirectiveInject */](core_MatOptgroupBase)); };\n    _MatOptionBase.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: _MatOptionBase, inputs: { id: \"id\", disabled: \"disabled\", value: \"value\" }, outputs: { onSelectionChange: \"onSelectionChange\" } });\n    return _MatOptionBase;\n})();\nlet core_MatOption = /*@__PURE__*/ (() => {\n    class MatOption extends core_MatOptionBase {\n        constructor(element, changeDetectorRef, parent, group) {\n            super(element, changeDetectorRef, parent, group);\n        }\n    }\n    MatOption.ɵfac = function MatOption_Factory(t) { return new (t || MatOption)(core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](MAT_OPTION_PARENT_COMPONENT, 8), core[\"Ob\" /* ɵɵdirectiveInject */](MAT_OPTGROUP, 8)); };\n    MatOption.ɵcmp = /*@__PURE__*/ core[\"Ib\" /* ɵɵdefineComponent */]({ type: MatOption, selectors: [[\"mat-option\"]], hostAttrs: [\"role\", \"option\", 1, \"mat-option\", \"mat-focus-indicator\"], hostVars: 12, hostBindings: function MatOption_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                core[\"ec\" /* ɵɵlistener */](\"click\", function MatOption_click_HostBindingHandler() { return ctx._selectViaInteraction(); })(\"keydown\", function MatOption_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); });\n            }\n            if (rf & 2) {\n                core[\"Xb\" /* ɵɵhostProperty */](\"id\", ctx.id);\n                core[\"Db\" /* ɵɵattribute */](\"tabindex\", ctx._getTabIndex())(\"aria-selected\", ctx._getAriaSelected())(\"aria-disabled\", ctx.disabled.toString());\n                core[\"Gb\" /* ɵɵclassProp */](\"mat-selected\", ctx.selected)(\"mat-option-multiple\", ctx.multiple)(\"mat-active\", ctx.active)(\"mat-option-disabled\", ctx.disabled);\n            }\n        }, exportAs: [\"matOption\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c2, decls: 5, vars: 4, consts: [[\"class\", \"mat-option-pseudo-checkbox\", 3, \"state\", \"disabled\", 4, \"ngIf\"], [1, \"mat-option-text\"], [\"class\", \"cdk-visually-hidden\", 4, \"ngIf\"], [\"mat-ripple\", \"\", 1, \"mat-option-ripple\", 3, \"matRippleTrigger\", \"matRippleDisabled\"], [1, \"mat-option-pseudo-checkbox\", 3, \"state\", \"disabled\"], [1, \"cdk-visually-hidden\"]], template: function MatOption_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"nc\" /* ɵɵprojectionDef */]();\n                core[\"Fc\" /* ɵɵtemplate */](0, MatOption_mat_pseudo_checkbox_0_Template, 1, 2, \"mat-pseudo-checkbox\", 0);\n                core[\"Ub\" /* ɵɵelementStart */](1, \"span\", 1);\n                core[\"mc\" /* ɵɵprojection */](2);\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"Fc\" /* ɵɵtemplate */](3, MatOption_span_3_Template, 2, 1, \"span\", 2);\n                core[\"Pb\" /* ɵɵelement */](4, \"div\", 3);\n            }\n            if (rf & 2) {\n                core[\"oc\" /* ɵɵproperty */](\"ngIf\", ctx.multiple);\n                core[\"Cb\" /* ɵɵadvance */](3);\n                core[\"oc\" /* ɵɵproperty */](\"ngIf\", ctx.group && ctx.group._inert);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"oc\" /* ɵɵproperty */](\"matRippleTrigger\", ctx._getHostElement())(\"matRippleDisabled\", ctx.disabled || ctx.disableRipple);\n            }\n        }, directives: [common[\"m\" /* NgIf */], core_MatRipple, core_MatPseudoCheckbox], styles: [\".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.cdk-high-contrast-active .mat-option[aria-disabled=true]{opacity:.5}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatOption;\n})();\n/**\n * Counts the amount of option group labels that precede the specified option.\n * @param optionIndex Index of the option at which to start counting.\n * @param options Flat list of all of the options.\n * @param optionGroups Flat list of all of the option groups.\n * @docs-private\n */\nfunction _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {\n    if (optionGroups.length) {\n        let optionsArray = options.toArray();\n        let groups = optionGroups.toArray();\n        let groupCounter = 0;\n        for (let i = 0; i < optionIndex + 1; i++) {\n            if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {\n                groupCounter++;\n            }\n        }\n        return groupCounter;\n    }\n    return 0;\n}\n/**\n * Determines the position to which to scroll a panel in order for an option to be into view.\n * @param optionOffset Offset of the option from the top of the panel.\n * @param optionHeight Height of the options.\n * @param currentScrollPosition Current scroll position of the panel.\n * @param panelHeight Height of the panel.\n * @docs-private\n */\nfunction _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {\n    if (optionOffset < currentScrollPosition) {\n        return optionOffset;\n    }\n    if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {\n        return Math.max(0, optionOffset - panelHeight + optionHeight);\n    }\n    return currentScrollPosition;\n}\nlet core_MatOptionModule = /*@__PURE__*/ (() => {\n    class MatOptionModule {\n    }\n    MatOptionModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: MatOptionModule });\n    MatOptionModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function MatOptionModule_Factory(t) { return new (t || MatOptionModule)(); }, imports: [[core_MatRippleModule, common[\"c\" /* CommonModule */], core_MatCommonModule, core_MatPseudoCheckboxModule]] });\n    return MatOptionModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](core_MatOptionModule, { declarations: function () { return [core_MatOption, core_MatOptgroup]; }, imports: function () { return [core_MatRippleModule, common[\"c\" /* CommonModule */], core_MatCommonModule, core_MatPseudoCheckboxModule]; }, exports: function () { return [core_MatOption, core_MatOptgroup]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=core.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/checkbox.js\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token to be used to override the default options for `mat-checkbox`. */\n\n\n\n\nconst checkbox_c0 = [\"input\"];\nconst checkbox_c1 = function () { return { enterDuration: 150 }; };\nconst checkbox_c2 = [\"*\"];\nconst MAT_CHECKBOX_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"r\" /* InjectionToken */]('mat-checkbox-default-options', {\n    providedIn: 'root',\n    factory: MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY\n});\n/** @docs-private */\nfunction MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        color: 'accent',\n        clickAction: 'check-indeterminate',\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Increasing integer for generating unique ids for checkbox components.\nlet nextUniqueId = 0;\n// Default checkbox configuration.\nconst defaults = /*@__PURE__*/ MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY();\n/**\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nconst MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n    provide: fesm2015_forms[\"i\" /* NG_VALUE_ACCESSOR */],\n    useExisting: /*@__PURE__*/ Object(core[\"V\" /* forwardRef */])(() => checkbox_MatCheckbox),\n    multi: true\n};\n/** Change event object emitted by MatCheckbox. */\nclass MatCheckboxChange {\n}\n// Boilerplate for applying mixins to MatCheckbox.\n/** @docs-private */\nclass MatCheckboxBase {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nconst _MatCheckboxMixinBase = /*@__PURE__*/ mixinTabIndex(/*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinDisabled(MatCheckboxBase))));\nlet checkbox_MatCheckbox = /*@__PURE__*/ (() => {\n    class MatCheckbox extends _MatCheckboxMixinBase {\n        constructor(elementRef, _changeDetectorRef, _focusMonitor, _ngZone, tabIndex, _animationMode, _options) {\n            super(elementRef);\n            this._changeDetectorRef = _changeDetectorRef;\n            this._focusMonitor = _focusMonitor;\n            this._ngZone = _ngZone;\n            this._animationMode = _animationMode;\n            this._options = _options;\n            /**\n             * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n             * take precedence so this may be omitted.\n             */\n            this.ariaLabel = '';\n            /**\n             * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n             */\n            this.ariaLabelledby = null;\n            this._uniqueId = `mat-checkbox-${++nextUniqueId}`;\n            /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\n            this.id = this._uniqueId;\n            /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\n            this.labelPosition = 'after';\n            /** Name value will be applied to the input element if present */\n            this.name = null;\n            /** Event emitted when the checkbox's `checked` value changes. */\n            this.change = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the checkbox's `indeterminate` value changes. */\n            this.indeterminateChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n             * @docs-private\n             */\n            this._onTouched = () => { };\n            this._currentAnimationClass = '';\n            this._currentCheckState = 0 /* Init */;\n            this._controlValueAccessorChangeFn = () => { };\n            this._checked = false;\n            this._disabled = false;\n            this._indeterminate = false;\n            this._options = this._options || defaults;\n            this.color = this.defaultColor = this._options.color || defaults.color;\n            this.tabIndex = parseInt(tabIndex) || 0;\n        }\n        /** Returns the unique id for the visual hidden input. */\n        get inputId() { return `${this.id || this._uniqueId}-input`; }\n        /** Whether the checkbox is required. */\n        get required() { return this._required; }\n        set required(value) { this._required = coerceBooleanProperty(value); }\n        ngAfterViewInit() {\n            this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n                if (!focusOrigin) {\n                    // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n                    // Angular does not expect events to be raised during change detection, so any state change\n                    // (such as a form control's 'ng-touched') will cause a changed-after-checked error.\n                    // See https://github.com/angular/angular/issues/17793. To work around this, we defer\n                    // telling the form control it has been touched until the next tick.\n                    Promise.resolve().then(() => {\n                        this._onTouched();\n                        this._changeDetectorRef.markForCheck();\n                    });\n                }\n            });\n            this._syncIndeterminate(this._indeterminate);\n        }\n        // TODO: Delete next major revision.\n        ngAfterViewChecked() { }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n        /**\n         * Whether the checkbox is checked.\n         */\n        get checked() { return this._checked; }\n        set checked(value) {\n            if (value != this.checked) {\n                this._checked = value;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * Whether the checkbox is disabled. This fully overrides the implementation provided by\n         * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.\n         */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            const newValue = coerceBooleanProperty(value);\n            if (newValue !== this.disabled) {\n                this._disabled = newValue;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n         * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n         * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n         * set to false.\n         */\n        get indeterminate() { return this._indeterminate; }\n        set indeterminate(value) {\n            const changed = value != this._indeterminate;\n            this._indeterminate = coerceBooleanProperty(value);\n            if (changed) {\n                if (this._indeterminate) {\n                    this._transitionCheckState(3 /* Indeterminate */);\n                }\n                else {\n                    this._transitionCheckState(this.checked ? 1 /* Checked */ : 2 /* Unchecked */);\n                }\n                this.indeterminateChange.emit(this._indeterminate);\n            }\n            this._syncIndeterminate(this._indeterminate);\n        }\n        _isRippleDisabled() {\n            return this.disableRipple || this.disabled;\n        }\n        /** Method being called whenever the label text changes. */\n        _onLabelTextChange() {\n            // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox\n            // component will be only marked for check, but no actual change detection runs automatically.\n            // Instead of going back into the zone in order to trigger a change detection which causes\n            // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger\n            // an explicit change detection for the checkbox view and its children.\n            this._changeDetectorRef.detectChanges();\n        }\n        // Implemented as part of ControlValueAccessor.\n        writeValue(value) {\n            this.checked = !!value;\n        }\n        // Implemented as part of ControlValueAccessor.\n        registerOnChange(fn) {\n            this._controlValueAccessorChangeFn = fn;\n        }\n        // Implemented as part of ControlValueAccessor.\n        registerOnTouched(fn) {\n            this._onTouched = fn;\n        }\n        // Implemented as part of ControlValueAccessor.\n        setDisabledState(isDisabled) {\n            this.disabled = isDisabled;\n        }\n        _getAriaChecked() {\n            if (this.checked) {\n                return 'true';\n            }\n            return this.indeterminate ? 'mixed' : 'false';\n        }\n        _transitionCheckState(newState) {\n            let oldState = this._currentCheckState;\n            let element = this._elementRef.nativeElement;\n            if (oldState === newState) {\n                return;\n            }\n            if (this._currentAnimationClass.length > 0) {\n                element.classList.remove(this._currentAnimationClass);\n            }\n            this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\n            this._currentCheckState = newState;\n            if (this._currentAnimationClass.length > 0) {\n                element.classList.add(this._currentAnimationClass);\n                // Remove the animation class to avoid animation when the checkbox is moved between containers\n                const animationClass = this._currentAnimationClass;\n                this._ngZone.runOutsideAngular(() => {\n                    setTimeout(() => {\n                        element.classList.remove(animationClass);\n                    }, 1000);\n                });\n            }\n        }\n        _emitChangeEvent() {\n            const event = new MatCheckboxChange();\n            event.source = this;\n            event.checked = this.checked;\n            this._controlValueAccessorChangeFn(this.checked);\n            this.change.emit(event);\n            // Assigning the value again here is redundant, but we have to do it in case it was\n            // changed inside the `change` listener which will cause the input to be out of sync.\n            if (this._inputElement) {\n                this._inputElement.nativeElement.checked = this.checked;\n            }\n        }\n        /** Toggles the `checked` state of the checkbox. */\n        toggle() {\n            this.checked = !this.checked;\n        }\n        /**\n         * Event handler for checkbox input element.\n         * Toggles checked state if element is not disabled.\n         * Do not toggle on (change) event since IE doesn't fire change event when\n         *   indeterminate checkbox is clicked.\n         * @param event\n         */\n        _onInputClick(event) {\n            var _a;\n            const clickAction = (_a = this._options) === null || _a === void 0 ? void 0 : _a.clickAction;\n            // We have to stop propagation for click events on the visual hidden input element.\n            // By default, when a user clicks on a label element, a generated click event will be\n            // dispatched on the associated input element. Since we are using a label element as our\n            // root container, the click event on the `checkbox` will be executed twice.\n            // The real click event will bubble up, and the generated click event also tries to bubble up.\n            // This will lead to multiple click events.\n            // Preventing bubbling for the second event will solve that issue.\n            event.stopPropagation();\n            // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click\n            if (!this.disabled && clickAction !== 'noop') {\n                // When user manually click on the checkbox, `indeterminate` is set to false.\n                if (this.indeterminate && clickAction !== 'check') {\n                    Promise.resolve().then(() => {\n                        this._indeterminate = false;\n                        this.indeterminateChange.emit(this._indeterminate);\n                    });\n                }\n                this.toggle();\n                this._transitionCheckState(this._checked ? 1 /* Checked */ : 2 /* Unchecked */);\n                // Emit our custom change event if the native input emitted one.\n                // It is important to only emit it, if the native input triggered one, because\n                // we don't want to trigger a change event, when the `checked` variable changes for example.\n                this._emitChangeEvent();\n            }\n            else if (!this.disabled && clickAction === 'noop') {\n                // Reset native input when clicked with noop. The native checkbox becomes checked after\n                // click, reset it to be align with `checked` value of `mat-checkbox`.\n                this._inputElement.nativeElement.checked = this.checked;\n                this._inputElement.nativeElement.indeterminate = this.indeterminate;\n            }\n        }\n        /** Focuses the checkbox. */\n        focus(origin, options) {\n            if (origin) {\n                this._focusMonitor.focusVia(this._inputElement, origin, options);\n            }\n            else {\n                this._inputElement.nativeElement.focus(options);\n            }\n        }\n        _onInteractionEvent(event) {\n            // We always have to stop propagation on the change event.\n            // Otherwise the change event, from the input element, will bubble up and\n            // emit its event object to the `change` output.\n            event.stopPropagation();\n        }\n        _getAnimationClassForCheckStateTransition(oldState, newState) {\n            // Don't transition if animations are disabled.\n            if (this._animationMode === 'NoopAnimations') {\n                return '';\n            }\n            let animSuffix = '';\n            switch (oldState) {\n                case 0 /* Init */:\n                    // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n                    // [checked] bound to it.\n                    if (newState === 1 /* Checked */) {\n                        animSuffix = 'unchecked-checked';\n                    }\n                    else if (newState == 3 /* Indeterminate */) {\n                        animSuffix = 'unchecked-indeterminate';\n                    }\n                    else {\n                        return '';\n                    }\n                    break;\n                case 2 /* Unchecked */:\n                    animSuffix = newState === 1 /* Checked */ ?\n                        'unchecked-checked' : 'unchecked-indeterminate';\n                    break;\n                case 1 /* Checked */:\n                    animSuffix = newState === 2 /* Unchecked */ ?\n                        'checked-unchecked' : 'checked-indeterminate';\n                    break;\n                case 3 /* Indeterminate */:\n                    animSuffix = newState === 1 /* Checked */ ?\n                        'indeterminate-checked' : 'indeterminate-unchecked';\n                    break;\n            }\n            return `mat-checkbox-anim-${animSuffix}`;\n        }\n        /**\n         * Syncs the indeterminate value with the checkbox DOM node.\n         *\n         * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a\n         * property is supported on an element boils down to `if (propName in element)`. Domino's\n         * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during\n         * server-side rendering.\n         */\n        _syncIndeterminate(value) {\n            const nativeCheckbox = this._inputElement;\n            if (nativeCheckbox) {\n                nativeCheckbox.nativeElement.indeterminate = value;\n            }\n        }\n    }\n    MatCheckbox.ɵfac = function MatCheckbox_Factory(t) { return new (t || MatCheckbox)(core[\"Ob\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Ob\" /* ɵɵdirectiveInject */](a11y_FocusMonitor), core[\"Ob\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"cc\" /* ɵɵinjectAttribute */]('tabindex'), core[\"Ob\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8), core[\"Ob\" /* ɵɵdirectiveInject */](MAT_CHECKBOX_DEFAULT_OPTIONS, 8)); };\n    MatCheckbox.ɵcmp = /*@__PURE__*/ core[\"Ib\" /* ɵɵdefineComponent */]({ type: MatCheckbox, selectors: [[\"mat-checkbox\"]], viewQuery: function MatCheckbox_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Mc\" /* ɵɵviewQuery */](checkbox_c0, true);\n                core[\"Mc\" /* ɵɵviewQuery */](core_MatRipple, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"vc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._inputElement = _t.first);\n                core[\"vc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx.ripple = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-checkbox\"], hostVars: 12, hostBindings: function MatCheckbox_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Xb\" /* ɵɵhostProperty */](\"id\", ctx.id);\n                core[\"Db\" /* ɵɵattribute */](\"tabindex\", null);\n                core[\"Gb\" /* ɵɵclassProp */](\"mat-checkbox-indeterminate\", ctx.indeterminate)(\"mat-checkbox-checked\", ctx.checked)(\"mat-checkbox-disabled\", ctx.disabled)(\"mat-checkbox-label-before\", ctx.labelPosition == \"before\")(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n            }\n        }, inputs: { disableRipple: \"disableRipple\", color: \"color\", tabIndex: \"tabIndex\", ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], id: \"id\", labelPosition: \"labelPosition\", name: \"name\", required: \"required\", checked: \"checked\", disabled: \"disabled\", indeterminate: \"indeterminate\", ariaDescribedby: [\"aria-describedby\", \"ariaDescribedby\"], value: \"value\" }, outputs: { change: \"change\", indeterminateChange: \"indeterminateChange\" }, exportAs: [\"matCheckbox\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: checkbox_c2, decls: 17, vars: 20, consts: [[1, \"mat-checkbox-layout\"], [\"label\", \"\"], [1, \"mat-checkbox-inner-container\"], [\"type\", \"checkbox\", 1, \"mat-checkbox-input\", \"cdk-visually-hidden\", 3, \"id\", \"required\", \"checked\", \"disabled\", \"tabIndex\", \"change\", \"click\"], [\"input\", \"\"], [\"matRipple\", \"\", 1, \"mat-checkbox-ripple\", \"mat-focus-indicator\", 3, \"matRippleTrigger\", \"matRippleDisabled\", \"matRippleRadius\", \"matRippleCentered\", \"matRippleAnimation\"], [1, \"mat-ripple-element\", \"mat-checkbox-persistent-ripple\"], [1, \"mat-checkbox-frame\"], [1, \"mat-checkbox-background\"], [\"version\", \"1.1\", \"focusable\", \"false\", \"viewBox\", \"0 0 24 24\", 0, \"xml\", \"space\", \"preserve\", 1, \"mat-checkbox-checkmark\"], [\"fill\", \"none\", \"stroke\", \"white\", \"d\", \"M4.1,12.7 9,17.6 20.3,6.3\", 1, \"mat-checkbox-checkmark-path\"], [1, \"mat-checkbox-mixedmark\"], [1, \"mat-checkbox-label\", 3, \"cdkObserveContent\"], [\"checkboxLabel\", \"\"], [2, \"display\", \"none\"]], template: function MatCheckbox_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"nc\" /* ɵɵprojectionDef */]();\n                core[\"Ub\" /* ɵɵelementStart */](0, \"label\", 0, 1);\n                core[\"Ub\" /* ɵɵelementStart */](2, \"span\", 2);\n                core[\"Ub\" /* ɵɵelementStart */](3, \"input\", 3, 4);\n                core[\"ec\" /* ɵɵlistener */](\"change\", function MatCheckbox_Template_input_change_3_listener($event) { return ctx._onInteractionEvent($event); })(\"click\", function MatCheckbox_Template_input_click_3_listener($event) { return ctx._onInputClick($event); });\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"Ub\" /* ɵɵelementStart */](5, \"span\", 5);\n                core[\"Pb\" /* ɵɵelement */](6, \"span\", 6);\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"Pb\" /* ɵɵelement */](7, \"span\", 7);\n                core[\"Ub\" /* ɵɵelementStart */](8, \"span\", 8);\n                core[\"hc\" /* ɵɵnamespaceSVG */]();\n                core[\"Ub\" /* ɵɵelementStart */](9, \"svg\", 9);\n                core[\"Pb\" /* ɵɵelement */](10, \"path\", 10);\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"gc\" /* ɵɵnamespaceHTML */]();\n                core[\"Pb\" /* ɵɵelement */](11, \"span\", 11);\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"Ub\" /* ɵɵelementStart */](12, \"span\", 12, 13);\n                core[\"ec\" /* ɵɵlistener */](\"cdkObserveContent\", function MatCheckbox_Template_span_cdkObserveContent_12_listener() { return ctx._onLabelTextChange(); });\n                core[\"Ub\" /* ɵɵelementStart */](14, \"span\", 14);\n                core[\"Hc\" /* ɵɵtext */](15, \"\\u00A0\");\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"mc\" /* ɵɵprojection */](16);\n                core[\"Tb\" /* ɵɵelementEnd */]();\n                core[\"Tb\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                const _r0 = core[\"wc\" /* ɵɵreference */](1);\n                const _r2 = core[\"wc\" /* ɵɵreference */](13);\n                core[\"Db\" /* ɵɵattribute */](\"for\", ctx.inputId);\n                core[\"Cb\" /* ɵɵadvance */](2);\n                core[\"Gb\" /* ɵɵclassProp */](\"mat-checkbox-inner-container-no-side-margin\", !_r2.textContent || !_r2.textContent.trim());\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"oc\" /* ɵɵproperty */](\"id\", ctx.inputId)(\"required\", ctx.required)(\"checked\", ctx.checked)(\"disabled\", ctx.disabled)(\"tabIndex\", ctx.tabIndex);\n                core[\"Db\" /* ɵɵattribute */](\"value\", ctx.value)(\"name\", ctx.name)(\"aria-label\", ctx.ariaLabel || null)(\"aria-labelledby\", ctx.ariaLabelledby)(\"aria-checked\", ctx._getAriaChecked())(\"aria-describedby\", ctx.ariaDescribedby);\n                core[\"Cb\" /* ɵɵadvance */](2);\n                core[\"oc\" /* ɵɵproperty */](\"matRippleTrigger\", _r0)(\"matRippleDisabled\", ctx._isRippleDisabled())(\"matRippleRadius\", 20)(\"matRippleCentered\", true)(\"matRippleAnimation\", core[\"rc\" /* ɵɵpureFunction0 */](19, checkbox_c1));\n            }\n        }, directives: [core_MatRipple, observers_CdkObserveContent], styles: [\"@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.910259}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);stroke-dashoffset:0}to{stroke-dashoffset:-22.910259}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0deg)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}32.8%,100%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{display:inline-block;transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}.cdk-high-contrast-active .mat-checkbox.cdk-keyboard-focused .mat-checkbox-frame{border-style:dotted}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0, 0, 0.2, 0.1),opacity 90ms cubic-bezier(0, 0, 0.2, 0.1);-webkit-print-color-adjust:exact;color-adjust:exact}._mat-animation-noopable .mat-checkbox-background{transition:none}.cdk-high-contrast-active .mat-checkbox .mat-checkbox-background{background:none}.mat-checkbox-persistent-ripple{display:block;width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media(hover: none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.910259;stroke-dasharray:22.910259;stroke-width:2.1333333333px}.cdk-high-contrast-black-on-white .mat-checkbox-checkmark-path{stroke:#000 !important}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0deg);border-radius:2px}.cdk-high-contrast-active .mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0deg)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.cdk-high-contrast-active .mat-checkbox-disabled{opacity:.5}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0ms mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0ms mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:300ms linear 0ms mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatCheckbox;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAT_CHECKBOX_REQUIRED_VALIDATOR = {\n    provide: fesm2015_forms[\"h\" /* NG_VALIDATORS */],\n    useExisting: /*@__PURE__*/ Object(core[\"V\" /* forwardRef */])(() => checkbox_MatCheckboxRequiredValidator),\n    multi: true\n};\nlet checkbox_MatCheckboxRequiredValidator = /*@__PURE__*/ (() => {\n    class MatCheckboxRequiredValidator extends fesm2015_forms[\"b\" /* CheckboxRequiredValidator */] {\n    }\n    MatCheckboxRequiredValidator.ɵfac = function MatCheckboxRequiredValidator_Factory(t) { return ɵMatCheckboxRequiredValidator_BaseFactory(t || MatCheckboxRequiredValidator); };\n    MatCheckboxRequiredValidator.ɵdir = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineDirective */]({ type: MatCheckboxRequiredValidator, selectors: [[\"mat-checkbox\", \"required\", \"\", \"formControlName\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"formControl\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"ngModel\", \"\"]], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([MAT_CHECKBOX_REQUIRED_VALIDATOR]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatCheckboxRequiredValidator;\n})();\nconst ɵMatCheckboxRequiredValidator_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Wb\" /* ɵɵgetInheritedFactory */](checkbox_MatCheckboxRequiredValidator);\nlet checkbox_MatCheckboxRequiredValidatorModule = /*@__PURE__*/ (() => {\n    class _MatCheckboxRequiredValidatorModule {\n    }\n    _MatCheckboxRequiredValidatorModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: _MatCheckboxRequiredValidatorModule });\n    _MatCheckboxRequiredValidatorModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function _MatCheckboxRequiredValidatorModule_Factory(t) { return new (t || _MatCheckboxRequiredValidatorModule)(); } });\n    return _MatCheckboxRequiredValidatorModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](checkbox_MatCheckboxRequiredValidatorModule, { declarations: [checkbox_MatCheckboxRequiredValidator], exports: [checkbox_MatCheckboxRequiredValidator] }); })();\nlet checkbox_MatCheckboxModule = /*@__PURE__*/ (() => {\n    class MatCheckboxModule {\n    }\n    MatCheckboxModule.ɵmod = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineNgModule */]({ type: MatCheckboxModule });\n    MatCheckboxModule.ɵinj = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjector */]({ factory: function MatCheckboxModule_Factory(t) { return new (t || MatCheckboxModule)(); }, imports: [[\n                core_MatRippleModule, core_MatCommonModule, observers_ObserversModule,\n                checkbox_MatCheckboxRequiredValidatorModule\n            ], core_MatCommonModule, checkbox_MatCheckboxRequiredValidatorModule] });\n    return MatCheckboxModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ac\" /* ɵɵsetNgModuleScope */](checkbox_MatCheckboxModule, { declarations: function () { return [checkbox_MatCheckbox]; }, imports: function () { return [core_MatRippleModule, core_MatCommonModule, observers_ObserversModule, checkbox_MatCheckboxRequiredValidatorModule]; }, exports: function () { return [checkbox_MatCheckbox, core_MatCommonModule, checkbox_MatCheckboxRequiredValidatorModule]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=checkbox.js.map\n\n\n/***/ }),\n\n/***/ \"jT/F\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return UploadService; });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"z6cu\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"JIr8\");\n/* harmony import */ var src_environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"AytR\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"tk/3\");\n\r\n\r\n\r\n\r\n\r\nlet UploadService = /*@__PURE__*/ (() => {\r\n    class UploadService {\r\n        constructor(http) {\r\n            this.http = http;\r\n            this.API_URL = `${src_environments_environment__WEBPACK_IMPORTED_MODULE_2__[/* environment */ \"a\"].apiUrl}` + 'api/Upload';\r\n        }\r\n        uploadImagen(file) {\r\n            const formData = new FormData();\r\n            formData.append(\"file\", file, file.name);\r\n            return this.http.post(this.API_URL + \"?carpeta=imagenes\", formData, {\r\n                reportProgress: true,\r\n                observe: 'events',\r\n            }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* catchError */ \"a\"])(this.errorMgmt));\r\n        }\r\n        uploadDocumento(file) {\r\n            const formData = new FormData();\r\n            formData.append(\"file\", file, file.name);\r\n            return this.http.post(this.API_URL + \"?carpeta=documentos\", formData, {\r\n                reportProgress: true,\r\n                observe: 'events',\r\n            }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* catchError */ \"a\"])(this.errorMgmt));\r\n        }\r\n        errorMgmt(error) {\r\n            let errorMessage = '';\r\n            if (error.error instanceof ErrorEvent) {\r\n                // Get client-side error\r\n                errorMessage = error.error.message;\r\n            }\r\n            else {\r\n                // Get server-side error\r\n                errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\r\n            }\r\n            console.log(errorMessage);\r\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* throwError */ \"a\"])(() => {\r\n                return errorMessage;\r\n            });\r\n        }\r\n    }\r\n    UploadService.ɵfac = function UploadService_Factory(t) { return new (t || UploadService)(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵinject */ \"bc\"](_angular_common_http__WEBPACK_IMPORTED_MODULE_4__[/* HttpClient */ \"c\"])); };\r\n    UploadService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineInjectable */ \"Kb\"]({ token: UploadService, factory: UploadService.ɵfac, providedIn: 'root' });\r\n    return UploadService;\r\n})();\r\n\n\n/***/ })\n\n}]);","inputSourceMap":null}