import * as i0 from '@angular/core';
import { Injectable, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';

const sumValues = (source, keys) => {
    let result = 0;
    keys.forEach((key) => {
        const property = source[key];
        const value = parseInt(property, 10) || 0;
        result += value;
    });
    return result;
};
const getScale = (imageHeight, imageWidth, maxHeight, maxWidth) => {
    const widthScale = maxWidth / imageWidth;
    const heightScale = maxHeight / imageHeight;
    const widthScaleIsOkay = imageHeight * widthScale <= maxHeight;
    return widthScaleIsOkay ? widthScale : heightScale;
};
const unzoomImage = (image) => {
    image.style.transform = 'scale(1)';
    image.parentElement?.classList.remove('image-zoom-wrapper-zoomed');
    image.addEventListener('transitionend', () => {
        image.classList.remove('image-zoom-zoomed');
    }, {
        once: true,
    });
};

const css = `
:root {
    overflow-x: hidden;
}
.image-zoom-wrapper::after {
    opacity: 0;
    transition: opacity 150ms cubic-bezier(.25, .1, .25 ,1);
    display: block;
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: white;
    z-index: 99998;
    pointer-events: none;
}
.image-zoom-wrapper.image-zoom-wrapper-zoomed::after {
    opacity: 1;
    cursor: zoom-out;
    pointer-events: all;
}
.image-zoom {
    transition: transform 300ms cubic-bezier(.25, .1, .25 ,1);
    cursor: zoom-in;
}
.image-zoom-zoomed {
    position: relative;
    z-index: 99999;
    cursor: zoom-out !important;
}
`;

function debounce(func, waitMilliseconds = 50, options = {}) {
    let timeoutId;
    const isImmediate = options.isImmediate ?? false;
    const callback = options.callback ?? false;
    const maxWait = options.maxWait;
    let lastInvokeTime = Date.now();
    let promises = [];
    function nextInvokeTimeout() {
        if (maxWait !== undefined) {
            const timeSinceLastInvocation = Date.now() - lastInvokeTime;
            if (timeSinceLastInvocation + waitMilliseconds >= maxWait) {
                return maxWait - timeSinceLastInvocation;
            }
        }
        return waitMilliseconds;
    }
    const debouncedFunction = function (...args) {
        const context = this;
        return new Promise((resolve, reject) => {
            const invokeFunction = function () {
                timeoutId = undefined;
                lastInvokeTime = Date.now();
                if (!isImmediate) {
                    const result = func.apply(context, args);
                    callback && callback(result);
                    promises.forEach(({ resolve }) => resolve(result));
                    promises = [];
                }
            };
            const shouldCallNow = isImmediate && timeoutId === undefined;
            if (timeoutId !== undefined) {
                clearTimeout(timeoutId);
            }
            timeoutId = setTimeout(invokeFunction, nextInvokeTimeout());
            if (shouldCallNow) {
                const result = func.apply(context, args);
                callback && callback(result);
                return resolve(result);
            }
            promises.push({ resolve, reject });
        });
    };
    debouncedFunction.cancel = function (reason) {
        if (timeoutId !== undefined) {
            clearTimeout(timeoutId);
        }
        promises.forEach(({ reject }) => reject(reason));
        promises = [];
    };
    return debouncedFunction;
}

class NgZoom {
    constructor(document) {
        this.document = document;
        this.defaultConfig = {
            padding: 20,
            exceed: false,
        };
        this.zoomed = null;
        this.handleClick = debounce((image) => {
            if (this.zoomed) {
                unzoomImage(this.zoomed);
                this.zoomed = null;
                return;
            }
            if (image) {
                this.zoomImage(image, this.defaultConfig);
                this.zoomed = image;
            }
        }, 500, {
            isImmediate: true,
        });
        this.handleUnzoomingInteraction = () => {
            if (!this.zoomed)
                return;
            unzoomImage(this.zoomed);
            this.zoomed = null;
        };
        this.handleKeydown = (e) => {
            if (e.code != 'Escape')
                return;
            e.preventDefault();
            if (this.zoomed) {
                unzoomImage(this.zoomed);
                this.zoomed = null;
            }
        };
        this.injectStyles = () => {
            const styles = this.document.createElement('style');
            styles.innerHTML = css;
            this.document.head.appendChild(styles);
        };
        this.zoomImage = (image, config) => {
            const imageRect = image.getBoundingClientRect();
            const imageStyle = this.window.getComputedStyle(image);
            const imageWidth = imageRect.width -
                sumValues(imageStyle, [
                    'borderLeftWidth',
                    'borderRightWidth',
                    'paddingLeft',
                    'paddingRight',
                ]);
            const imageHeight = imageRect.height -
                sumValues(imageStyle, [
                    'borderTopWidth',
                    'borderBottomWidth',
                    'paddingTop',
                    'paddingBottom',
                ]);
            const vw = this.window.innerWidth;
            const vh = this.window.innerHeight;
            const shouldExceed = config.exceed || image.dataset?.['imageZoomExceed'] == 'true';
            let scale = getScale(imageHeight, imageWidth, vh, vw);
            if (!shouldExceed) {
                const limitedScale = getScale(imageHeight, imageWidth, image.naturalHeight, image.naturalWidth);
                scale = Math.min(scale, limitedScale);
            }
            const isPaddingNeeded = config.padding >
                Math.min(vh - imageHeight * scale, vw - imageWidth * scale) / 2;
            if (isPaddingNeeded) {
                let scaleWithPaddingBeforeExceed = getScale(imageHeight + config.padding, imageWidth + config.padding, vh, vw);
                if (!shouldExceed) {
                    const limitedScale = getScale(imageHeight, imageWidth, image.naturalHeight - config.padding, image.naturalWidth - config.padding);
                    scaleWithPaddingBeforeExceed = Math.min(scaleWithPaddingBeforeExceed, limitedScale);
                }
                scale = scaleWithPaddingBeforeExceed;
            }
            const doc = this.document.documentElement;
            const scrollLeft = (this.window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
            const scrollTop = (this.window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
            const imageCenterX = scrollLeft + imageRect.left + imageRect.width / 2;
            const imageCenterY = scrollTop + imageRect.top + imageRect.height / 2;
            const screenCenterX = scrollLeft + vw / 2;
            const screenCenterY = scrollTop + vh / 2;
            const translateX = (screenCenterX - imageCenterX) / scale;
            const translateY = (screenCenterY - imageCenterY) / scale;
            image.classList.add('image-zoom-zoomed');
            image.parentElement?.classList.add('image-zoom-wrapper-zoomed');
            image.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
        };
        this.processImage = (image) => {
            // create an image wrapper element
            const wrapper = this.document.createElement('div');
            // let wrapper mimick pearl display property to not break anything
            wrapper.classList.add('image-zoom-wrapper');
            wrapper.style.display = this.window.getComputedStyle(image).display;
            image.parentElement?.insertBefore(wrapper, image);
            wrapper.appendChild(image);
            image.classList.add('image-zoom');
            image.style.transform = 'scale(1)';
        };
        this.window = this.document.defaultView;
        this.injectStyles();
        this.document.body.addEventListener('click', () => {
            this.handleClick(null);
        });
        this.document.addEventListener('keydown', this.handleKeydown);
        this.window.addEventListener('scroll', this.handleUnzoomingInteraction);
        this.window.addEventListener('resize', this.handleUnzoomingInteraction);
    }
    listen(imageRef) {
        const image = imageRef.nativeElement;
        this.processImage(image);
        image.addEventListener('click', () => {
            this.handleClick(image);
        });
    }
}
NgZoom.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: NgZoom, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
NgZoom.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: NgZoom, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: NgZoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

/*
 * Public API Surface of ng-zoom
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgZoom };
//# sourceMappingURL=ng-zoom.mjs.map
